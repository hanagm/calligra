From 52e4cd8852394df7ea8dc3f6a812e2c93d494ccb Mon Sep 17 00:00:00 2001
From: Damien Caliste <dcaliste@free.fr>
Date: Tue, 11 Dec 2018 13:02:17 +0100
Subject: [PATCH 01/14] Add fake kde4libs headers.

---
 plugins/pictureshape/kfile.h       |   64 +
 plugins/pictureshape/kfilewidget.h |  216 +++
 plugins/pictureshape/kurl.h        |  387 +++++
 sheets/kcalendarsystem.h           | 1014 +++++++++++++
 sheets/kfind.h                     |   74 +
 sheets/kfinddialog.h               |   30 +
 sheets/klocale.h                   | 2140 ++++++++++++++++++++++++++++
 sheets/kreplace.h                  |   28 +
 sheets/kreplacedialog.h            |   22 +
 sheets/ktextedit.h                 |   13 +
 10 files changed, 3988 insertions(+)
 create mode 100644 plugins/pictureshape/kfile.h
 create mode 100644 plugins/pictureshape/kfilewidget.h
 create mode 100644 plugins/pictureshape/kurl.h
 create mode 100644 sheets/kcalendarsystem.h
 create mode 100644 sheets/kfind.h
 create mode 100644 sheets/kfinddialog.h
 create mode 100644 sheets/klocale.h
 create mode 100644 sheets/kreplace.h
 create mode 100644 sheets/kreplacedialog.h
 create mode 100644 sheets/ktextedit.h

diff --git a/plugins/pictureshape/kfile.h b/plugins/pictureshape/kfile.h
new file mode 100644
index 00000000000..975cc53da20
--- /dev/null
+++ b/plugins/pictureshape/kfile.h
@@ -0,0 +1,64 @@
+#ifndef FAKE_KFILE_H
+#define FAKE_KFILE_H
+
+#include <QObject>
+
+class KFile
+{
+    Q_GADGET
+    Q_FLAGS(Modes)
+public:
+    enum Mode {
+        File         = 1,
+        Directory    = 2,
+        Files        = 4,
+        ExistingOnly = 8,
+        LocalOnly    = 16,
+        ModeMax      = 65536
+    };
+    Q_DECLARE_FLAGS(Modes, Mode)
+
+    enum FileView {
+        Default         = 0,
+        Simple          = 1,
+        Detail          = 2,
+        SeparateDirs    = 4,
+        PreviewContents = 8,
+        PreviewInfo     = 16,
+        Tree            = 32,
+        DetailTree      = 64,
+        FileViewMax     = 65536
+    };
+
+    enum SelectionMode {
+        Single      = 1,
+        Multi       = 2,
+        Extended    = 4,
+        NoSelection = 8
+    };
+
+#if 0
+    static bool isSortByName( const QDir::SortFlags& sort );
+    static bool isSortBySize( const QDir::SortFlags& sort );
+    static bool isSortByDate( const QDir::SortFlags& sort );
+    static bool isSortByType( const QDir::SortFlags& sort );
+    static bool isSortDirsFirst( const QDir::SortFlags& sort );
+    static bool isSortCaseInsensitive( const QDir::SortFlags& sort );
+
+    static bool isDefaultView( const FileView& view );
+    static bool isSimpleView( const FileView& view );
+    static bool isDetailView( const FileView& view );
+    static bool isSeparateDirs( const FileView& view );
+    static bool isPreviewContents( const FileView& view );
+    static bool isPreviewInfo( const FileView& view );
+    static bool isTreeView( const FileView& view );
+    static bool isDetailTreeView( const FileView& view );
+#endif
+
+private:
+    KFile() {}
+};
+
+Q_DECLARE_OPERATORS_FOR_FLAGS(KFile::Modes)
+
+#endif
diff --git a/plugins/pictureshape/kfilewidget.h b/plugins/pictureshape/kfilewidget.h
new file mode 100644
index 00000000000..36f0da8750a
--- /dev/null
+++ b/plugins/pictureshape/kfilewidget.h
@@ -0,0 +1,216 @@
+#ifndef FAKE_KFILEWIDGET_H
+#define FAKE_KFILEWIDGET_H
+
+#include <QWidget>
+#include <kfile.h>
+#include <kurl.h>
+/*#include <kmimetype.h>
+#include <kdiroperator.h>
+#include <kactioncollection.h>
+#include <ktoolbar.h>
+#include <kpushbutton.h>
+#include <kurlcombobox.h>
+
+#include "kofake_export.h"*/
+
+class KFileFilterCombo;
+
+class Q_DECL_EXPORT KFileWidget : public QWidget
+{
+    Q_OBJECT
+public:
+    enum OperationMode { Other = 0, Opening, Saving };
+
+    KFileWidget(const KUrl& startDir, QWidget *parent)
+        : QWidget(parent), m_opMode(Opening), m_modes(KFile::File | KFile::Directory)
+    {
+    }
+
+#if 0
+    void setConfirmOverwrite(bool enable){  // KDE5 TODO: make this virtual
+        virtual_hook(0, static_cast<void*>(&enable));
+    }
+    void setInlinePreviewShown(bool show) { // KDE5 TODO: make this virtual
+        virtual_hook(1, static_cast<void*>(&show));
+    }
+#endif
+
+    virtual KUrl selectedUrl() const { return m_selectedUrls.isEmpty() ? KUrl() : m_selectedUrls.first(); }
+    virtual KUrl::List selectedUrls() const { return m_selectedUrls; }
+    virtual KUrl baseUrl() const { return KUrl(); }
+    virtual QString selectedFile() const { return m_selectedUrls.isEmpty() ? QString() : m_selectedUrls.first().toLocalFile(); }
+    virtual QStringList selectedFiles() const
+    {
+        QStringList files;
+        Q_FOREACH(const KUrl &u, m_selectedUrls)
+            files.append(u.toLocalFile());
+        return files;
+    }
+
+    virtual void setUrl(const KUrl &url, bool clearforward = true) {}
+    virtual void setSelection(const QString& name) {}
+
+    virtual void setOperationMode( OperationMode m ) { m_opMode = m; }
+    virtual OperationMode operationMode() const { return m_opMode; }
+
+    virtual void setKeepLocation( bool keep ) {}
+    virtual bool keepsLocation() const { return false; }
+
+    virtual void setFilter(const QString&) {}
+    virtual QString currentFilter() const { return QString(); }
+    // virtual KMimeType::Ptr currentFilterMimeType() { return KMimeType::Ptr(); }
+    virtual void setMimeFilter( const QStringList& types, const QString& defaultType = QString() ) {}
+    virtual QString currentMimeFilter() const { return QString(); }
+    virtual void clearFilter() {}
+
+#if 0
+    virtual void setPreviewWidget(KPreviewWidgetBase *w);
+#endif
+
+    virtual void setMode( KFile::Modes m ) { m_modes = m; }
+    virtual KFile::Modes mode() const { return  m_modes; }
+
+    virtual void setLocationLabel(const QString& text) {}
+    /*KToolBar *toolBar() const { return 0; }
+    KPushButton *okButton() const { return 0; }
+    KPushButton *cancelButton() const { return 0; }
+    KUrlComboBox *locationEdit() const { return 0; }
+    KFileFilterCombo *filterWidget() const { return 0; }
+    KActionCollection *actionCollection() const { return 0; }*/
+
+#if 0
+    /**
+     * This method implements the logic to determine the user's default directory
+     * to be listed. E.g. the documents directory, home directory or a recently
+     * used directory.
+     * @param startDir A URL specifying the initial directory, or using the
+     *                 @c kfiledialog:/// syntax to specify a last used
+     *                 directory.  If this URL specifies a file name, it is
+     *                 ignored.  Refer to the KFileWidget::KFileWidget()
+     *                 documentation for the @c kfiledialog:/// URL syntax.
+     * @param recentDirClass If the @c kfiledialog:/// syntax is used, this
+     *        will return the string to be passed to KRecentDirs::dir() and
+     *        KRecentDirs::add().
+     * @return The URL that should be listed by default (e.g. by KFileDialog or
+     *         KDirSelectDialog).
+     * @see KFileWidget::KFileWidget()
+     */
+    static KUrl getStartUrl( const KUrl& startDir, QString& recentDirClass );
+
+    /**
+     * Similar to getStartUrl(const KUrl& startDir,QString& recentDirClass),
+     * but allows both the recent start directory keyword and a suggested file name
+     * to be returned.
+     * @param startDir A URL specifying the initial directory and/or filename,
+     *                 or using the @c kfiledialog:/// syntax to specify a
+     *                 last used location.
+     *                 Refer to the KFileWidget::KFileWidget()
+     *                 documentation for the @c kfiledialog:/// URL syntax.
+     * @param recentDirClass If the @c kfiledialog:/// syntax is used, this
+     *        will return the string to be passed to KRecentDirs::dir() and
+     *        KRecentDirs::add().
+     * @param fileName The suggested file name, if specified as part of the
+     *        @p StartDir URL.
+     * @return The URL that should be listed by default (e.g. by KFileDialog or
+     *         KDirSelectDialog).
+     *
+     * @see KFileWidget::KFileWidget()
+     * @since 4.3
+     */
+    static KUrl getStartUrl( const KUrl& startDir, QString& recentDirClass, QString& fileName );
+
+    /**
+     * @internal
+     * Used by KDirSelectDialog to share the dialog's start directory.
+     */
+    static void setStartDir( const KUrl& directory );
+
+    virtual void setCustomWidget(QWidget* widget);
+    virtual void setCustomWidget(const QString& text, QWidget* widget);
+#endif
+
+    /**
+     * @returns the KDirOperator used to navigate the filesystem
+     * @since 4.3
+     */
+    // KDirOperator* dirOperator() { return 0; }
+
+#if 0
+    /**
+     * reads the configuration for this widget from the given config group
+     * @param group the KConfigGroup to read from
+     * @since 4.4
+     */
+    void readConfig( KConfigGroup& group );
+#endif
+
+public Q_SLOTS:
+    virtual void slotOk() {}
+    virtual void accept() {}
+    virtual void slotCancel() {}
+
+#if 0
+Q_SIGNALS:
+    /**
+      * Emitted when the user selects a file. It is only emitted in single-
+      * selection mode. The best way to get notified about selected file(s)
+      * is to connect to the okClicked() signal inherited from KDialog
+      * and call selectedFile(), selectedFiles(),
+      * selectedUrl() or selectedUrls().
+      *
+      * \since 4.4
+      */
+    void fileSelected(const KUrl&);
+
+    /**
+     * @deprecated, connect to fileSelected(const KUrl&) instead
+     */
+    QT_MOC_COMPAT void fileSelected(const QString&); // TODO KDE5: remove
+
+    /**
+     * Emitted when the user highlights a file.
+     * \since 4.4
+     */
+    void fileHighlighted(const KUrl&);
+    /**
+     * @deprecated, connect to fileSelected(const KUrl&) instead
+     */
+    QT_MOC_COMPAT void fileHighlighted(const QString&); // TODO KDE5: remove
+
+    /**
+     * Emitted when the user hilights one or more files in multiselection mode.
+     *
+     * Note: fileHighlighted() or fileSelected() are @em not
+     * emitted in multiselection mode. You may use selectedItems() to
+     * ask for the current highlighted items.
+     * @see fileSelected
+     */
+    void selectionChanged();
+
+    /**
+     * Emitted when the filter changed, i.e. the user entered an own filter
+     * or chose one of the predefined set via setFilter().
+     *
+     * @param filter contains the new filter (only the extension part,
+     * not the explanation), i.e. "*.cpp" or "*.cpp *.cc".
+     *
+     * @see setFilter()
+     * @see currentFilter()
+     */
+    void filterChanged( const QString& filter );
+
+    /**
+     * Emitted by slotOk() (directly or asynchronously) once everything has
+     * been done. Should be used by the caller to call accept().
+     */
+    void accepted();
+#endif
+
+private:
+    OperationMode m_opMode;
+    KFile::Modes m_modes;
+    KUrl::List m_selectedUrls;
+};
+
+#endif
+ 
diff --git a/plugins/pictureshape/kurl.h b/plugins/pictureshape/kurl.h
new file mode 100644
index 00000000000..a063767a25a
--- /dev/null
+++ b/plugins/pictureshape/kurl.h
@@ -0,0 +1,387 @@
+#ifndef FAKE_KURL_H
+#define FAKE_KURL_H
+
+#include <QUrl>
+#include <QUrlQuery>
+#include <QList>
+#include <QFileInfo>
+#include <QFile>
+#include <QDir>
+#include <QDebug>
+
+class KUrl : public QUrl
+{
+public:
+
+  class List : public QList<KUrl>
+  {
+  public:
+
+#if 0
+    /**
+     * Creates an empty List.
+     */
+      List() { }
+      /**
+       * Creates a list that contains the given URL as only
+       * item.
+       * @param url the url to add.
+       */
+      List(const KUrl &url);
+      /**
+       * Creates a list that contains the URLs from the given
+       * list of strings.
+       * @param list the list containing the URLs as strings
+       */
+      List(const QStringList &list);
+      /**
+       * Creates a list that contains the URLs from the given QList<KUrl>.
+       * @param list the list containing the URLs
+       */
+      List(const QList<KUrl> &list);
+      /**
+       * Creates a list that contains the URLs from the given QList<KUrl>.
+       * @param list the list containing the URLs
+       * @since 4.7
+       */
+      List(const QList<QUrl> &list);
+      /**
+       * Converts the URLs of this list to a list of strings.
+       * @return the list of strings
+       */
+      QStringList toStringList() const;
+
+      /**
+       * Converts the URLs of this list to a list of strings.
+       *
+       * @param trailing use to add or remove a trailing slash to/from the path.
+       *
+       * @return the list of strings
+       *
+       * @since 4.6
+       */
+      QStringList toStringList(KUrl::AdjustPathOption trailing) const;
+
+      /**
+       * Converts this KUrl::List to a QVariant, this allows to use KUrl::List
+       * in QVariant() constructor
+       */
+      operator QVariant() const;
+
+      /**
+       * Converts this KUrl::List into a list of QUrl instances.
+       * @since 4.7
+       */
+      operator QList<QUrl>() const;
+
+      /**
+       * Adds URLs data into the given QMimeData.
+       *
+       * By default, populateMimeData also exports the URLs as plain text, for e.g. dropping
+       * onto a text editor.
+       * But in some cases this might not be wanted, e.g. if adding other mime data
+       * which provides better plain text data.
+       *
+       * WARNING: do not call this method multiple times on the same mimedata object,
+       * you can add urls only once. But you can add other things, e.g. images, XML...
+       *
+       * @param mimeData the QMimeData instance used to drag or copy this URL
+       * @param metaData KIO metadata shipped in the mime data, which is used for instance to
+       * set a correct HTTP referrer (some websites require it for downloading e.g. an image)
+       * @param flags set NoTextExport to prevent setting plain/text data into @p mimeData
+       * In such a case, setExportAsText( false ) should be called.
+       */
+      void populateMimeData( QMimeData* mimeData,
+                             const KUrl::MetaDataMap& metaData = MetaDataMap(),
+                             MimeDataFlags flags = DefaultMimeDataFlags ) const;
+
+      /**
+       * Adds URLs into the given QMimeData.
+       *
+       * This should add both the KDE-style URLs (eg: desktop:/foo) and
+       * the "most local" version of the URLs (eg:
+       * file:///home/jbloggs/Desktop/foo) to the mimedata.
+       *
+       * This method should be called on the KDE-style URLs.
+       *
+       * @code
+       * QMimeData* mimeData = new QMimeData();
+       *
+       * KUrl::List kdeUrls;
+       * kdeUrls << "desktop:/foo";
+       * kdeUrls << "desktop:/bar";
+       *
+       * KUrl::List normalUrls;
+       * normalUrls << "file:///home/jbloggs/Desktop/foo";
+       * normalUrls << "file:///home/jbloggs/Desktop/bar";
+       *
+       * kdeUrls.populateMimeData(normalUrls, mimeData);
+       * @endcode
+       *
+       * @param mostLocalUrls the "most local" urls
+       * @param mimeData      the mime data object to populate
+       * @param metaData      KIO metadata shipped in the mime data, which is
+       *                      used for instance to set a correct HTTP referrer
+       *                      (some websites require it for downloading e.g. an
+       *                      image)
+       * @param flags         set NoTextExport to prevent setting plain/text
+       *                      data into @p mimeData. In such a case,
+       *                      <code>setExportAsText(false)</code> should be called.
+       * @since 4.2
+       */
+      void populateMimeData(const KUrl::List& mostLocalUrls,
+                            QMimeData* mimeData,
+                            const KUrl::MetaDataMap& metaData = MetaDataMap(),
+                            MimeDataFlags flags = DefaultMimeDataFlags) const;
+
+      /**
+       * Return true if @p mimeData contains URI data
+       */
+      static bool canDecode( const QMimeData *mimeData );
+
+      /**
+        * Return the list of mimeTypes that can be decoded by fromMimeData
+        */
+      static QStringList mimeDataTypes();
+
+      /**
+       * Extract a list of KUrls from the contents of @p mimeData.
+       * Decoding will fail if @p mimeData does not contain any URLs, or if at
+       * least one extracted URL is not valid.
+       * @param mimeData the mime data to extract from; cannot be 0
+       * @param metaData optional pointer to a map holding the metadata
+       * @return the list of urls
+       */
+      static KUrl::List fromMimeData( const QMimeData *mimeData, KUrl::MetaDataMap* metaData = 0 );
+
+      /**
+       * Flags to be used in fromMimeData.
+       * @since 4.2.3
+       */
+      enum DecodeOptions {
+        /**
+         * When the mimedata contains both KDE-style URLs (eg: desktop:/foo) and
+         * the "most local" version of the URLs (eg: file:///home/dfaure/Desktop/foo),
+         * decode it as local urls. Useful in paste/drop operations that end up calling KIO,
+         * so that urls from other users work as well.
+         */
+        PreferLocalUrls,
+        /**
+         * When the mimedata contains both KDE-style URLs (eg: desktop:/foo) and
+         * the "most local" version of the URLs (eg: file:///home/dfaure/Desktop/foo),
+         * decode it as the KDE-style URL. Useful in DnD code e.g. when moving icons,
+         * and the kde-style url is used as identifier for the icons.
+         */
+        PreferKdeUrls
+      };
+
+      /**
+       * Extract a list of KUrls from the contents of @p mimeData.
+       * Decoding will fail if @p mimeData does not contain any URLs, or if at
+       * least one extracted URL is not valid.
+       * @param mimeData the mime data to extract from; cannot be 0
+       * @param decodeOptions options for decoding
+       * @param metaData optional pointer to a map holding the metadata
+       * @return the list of urls
+       * @since 4.2.3
+       */
+      static KUrl::List fromMimeData( const QMimeData *mimeData,
+                                      DecodeOptions decodeOptions, // TODO KDE5: = PreferKdeUrls, and merge with above
+                                      KUrl::MetaDataMap* metaData = 0 );
+#endif
+    };
+
+    enum DirectoryOption { ObeyTrailingSlash = 0x02, AppendTrailingSlash = 0x04, IgnoreTrailingSlash = 0x01 };
+    Q_DECLARE_FLAGS(DirectoryOptions, DirectoryOption)
+
+    enum AdjustPathOption { RemoveTrailingSlash, LeaveTrailingSlash, AddTrailingSlash };
+
+    KUrl() : QUrl() {}
+    KUrl(const QString &urlOrPath) : QUrl(QUrl::fromLocalFile(urlOrPath)) {}
+    KUrl(const QByteArray& urlOrPath) : QUrl(QUrl::fromLocalFile(urlOrPath)) {}
+    KUrl(const char* urlOrPath) : QUrl(urlOrPath) {}
+    KUrl(const QUrl &u) : QUrl(u) {}
+    KUrl(const KUrl &u) : QUrl(u.toString()) {}
+
+    QByteArray protocol() const
+    {
+        return scheme().toUtf8();
+    }
+
+    void setProtocol(const QByteArray &p)
+    {
+        setScheme(QString::fromUtf8(p));
+    }
+
+//     QUrl url() const
+//     {
+//         return *this;
+//     }
+
+    QString url(AdjustPathOption = RemoveTrailingSlash) const
+    {
+        qDebug() << Q_FUNC_INFO << "url=" << toString();
+        //return toEncoded();
+        return toString();
+    }
+
+    QString toLocalFile( AdjustPathOption trailing = LeaveTrailingSlash ) const
+    {
+        if (!host().isEmpty() && isLocalFile()) {
+            KUrl urlWithoutHost(*this);
+            urlWithoutHost.setHost(QString());
+            return trailingSlash(trailing, urlWithoutHost.toLocalFile());
+        }
+
+        return trailingSlash(trailing, QUrl::toLocalFile());
+    }
+
+    static QString toPrettyPercentEncoding(const QString &input, bool forFragment)
+    {
+        QString result;
+        result.reserve(input.length());
+        for (int i = 0; i < input.length(); ++i) {
+            const QChar c = input.at(i);
+            register ushort u = c.unicode();
+            if (u < 0x20
+                || (!forFragment && u == '?') // don't escape '?' in fragments, not needed and wrong (#173101)
+                || u == '#' || u == '%'
+                || (u == ' ' && (i+1 == input.length() || input.at(i+1).unicode() == ' '))) {
+                static const char hexdigits[] = "0123456789ABCDEF";
+                result += QLatin1Char('%');
+                result += QLatin1Char(hexdigits[(u & 0xf0) >> 4]);
+                result += QLatin1Char(hexdigits[u & 0xf]);
+            } else {
+                result += c;
+            }
+        }
+        return result;
+    }
+
+    QString prettyUrl( AdjustPathOption trailing = LeaveTrailingSlash ) const
+    {
+        QString result = scheme();
+        if (!result.isEmpty()) {
+            if (!authority().isEmpty() || result == QLatin1String("file") || path().isEmpty())
+                result += QLatin1String("://");
+            else
+                result += QLatin1Char(':');
+        }
+
+        QString tmp = userName();
+        if (!tmp.isEmpty()) {
+            result += QString::fromLatin1(QUrl::toPercentEncoding(tmp));
+            result += QLatin1Char('@');
+        }
+
+        tmp = host();
+        if (tmp.contains(QLatin1Char(':')))
+            result += QLatin1Char('[') + tmp + QLatin1Char(']');
+        else
+            result += tmp;
+
+        if (port() != -1) {
+            result += QLatin1Char(':');
+            result += QString::number(port());
+        }
+
+        tmp = path();
+#ifdef Q_WS_WIN
+        if (isLocalFile())
+            tmp.prepend(QLatin1Char('/'));
+#endif
+        result += toPrettyPercentEncoding(tmp, false);
+
+        if (trailing == AddTrailingSlash && !tmp.endsWith(QLatin1Char('/')))
+            result += QLatin1Char('/');
+        else if (trailing == RemoveTrailingSlash && tmp.length() > 1 && tmp.endsWith(QLatin1Char('/')))
+            result.chop(1);
+
+        if (hasQuery()) {
+            result += QLatin1Char('?');
+            result += QUrlQuery(*static_cast<const QUrl*>(this)).toString(QUrl::FullyEncoded);
+        }
+        if (hasFragment()) {
+            result += QLatin1Char('#');
+            result += toPrettyPercentEncoding(fragment(), true);
+        }
+        return result;
+    }
+
+    QString pathOrUrl(AdjustPathOption trailing = LeaveTrailingSlash) const
+    {
+        if ( isLocalFile() && fragment().isNull() &&
+            QUrlQuery(*static_cast<const QUrl*>(this)).toString(QUrl::FullyEncoded).isEmpty() ) {
+            return toLocalFile(trailing);
+        } else {
+            return prettyUrl(trailing);
+        }
+    }
+
+    QString fileName(DirectoryOptions trailing = IgnoreTrailingSlash) const
+    {
+        Q_UNUSED(trailing);
+        return QFileInfo(toLocalFile()).fileName();
+    }
+
+    void setDirectory(const QString &dir)
+    {
+        setPath(QFileInfo(dir, fileName()).absoluteFilePath());
+    }
+
+    QString directory(const DirectoryOptions& options = IgnoreTrailingSlash) const
+    {
+        Q_UNUSED(options);
+        return QFileInfo(toLocalFile()).absolutePath();
+    }
+
+    void setFileName(const QString &file)
+    {
+        QFileInfo fi(QDir(directory()), file);
+        setPath(fi.filePath());
+    }
+
+    void addPath(QString s)
+    {
+        setPath(QFileInfo(path(), s).absoluteFilePath());
+    }
+
+    static KUrl fromPath(const QString &path)
+    {
+        return KUrl::fromLocalFile(path);
+    }
+
+    void adjustPath(AdjustPathOption trailing) {Q_UNUSED(trailing);}
+
+    static bool isRelativeUrl(const QString &url) { return QUrl(url).isRelative(); }
+
+private:
+
+    static QString trailingSlash( KUrl::AdjustPathOption trailing, const QString &path )
+    {
+        if ( trailing == KUrl::LeaveTrailingSlash )
+            return path;
+        QString result = path;
+        if ( trailing == KUrl::AddTrailingSlash ) {
+            int len = result.length();
+            if ( (len == 0) || (result[ len - 1 ] != QLatin1Char('/')) )
+                result += QLatin1Char('/');
+            return result;
+        } else if ( trailing == KUrl::RemoveTrailingSlash ) {
+            if ( result == QLatin1String("/") )
+                return result;
+            int len = result.length();
+            while (len > 1 && result[ len - 1 ] == QLatin1Char('/'))
+                len--;
+            result.truncate( len );
+            return result;
+        } else {
+            return result;
+        }
+    }
+
+};
+
+Q_DECLARE_METATYPE(KUrl)
+
+#endif
diff --git a/sheets/kcalendarsystem.h b/sheets/kcalendarsystem.h
new file mode 100644
index 00000000000..81c1e6496f9
--- /dev/null
+++ b/sheets/kcalendarsystem.h
@@ -0,0 +1,1014 @@
+#ifndef FAKE_KCALENDARSYSTEM_H
+#define FAKE_KCALENDARSYSTEM_H
+
+#include "klocale.h"
+
+#include <QStringList>
+#include <QDate>
+
+class KCalendarSystemPrivate;
+class KCalendarEra;
+class KLocale;
+
+class Q_DECL_EXPORT KCalendarSystem
+{
+public:
+    enum StringFormat { ShortFormat, LongFormat };
+    enum MonthNameFormat { ShortName, LongName, ShortNamePossessive, LongNamePossessive, NarrowName };
+    enum WeekDayNameFormat { ShortDayName, LongDayName, NarrowDayName };
+
+    //KDE5 add default value to calendarSystem
+    /**
+     * @since 4.6
+     *
+     * Creates a KCalendarSystem object for the required Calendar System
+     *
+     * @param calendarSystem the Calendar System to create, defaults to QDate compatible
+     * @param locale locale to use for translations. The global locale is used if null.
+     * @return a KCalendarSystem object
+     */
+    static KCalendarSystem *create(KLocale::CalendarSystem calendarSystem,
+                                   const KLocale *locale = 0) {return 0;}
+
+#if 0    /**
+     * @since 4.6
+     *
+     * Creates a KCalendarSystem object for the required Calendar System
+     *
+     * @param calendarSystem the Calendar System to create
+     * @param config a configuration file with a 'KCalendarSystem %calendarType' group detailing
+     *               locale-related preferences (such as era options).  The global config is used
+                     if null.
+     * @param locale locale to use for translations. The global locale is used if null.
+     * @return a KCalendarSystem object
+     */
+    static KCalendarSystem *create(KLocale::CalendarSystem calendarSystem, KSharedConfig::Ptr config,
+                                   const KLocale *locale = 0);
+
+    /**
+     * @since 4.6
+     *
+     * Returns the list of currently supported Calendar Systems
+     *
+     * @return list of Calendar Systems
+     */
+    static QList<KLocale::CalendarSystem> calendarSystemsList();
+
+    /**
+     * @since 4.6
+     *
+     * Returns a localized label to display for the required Calendar System type.
+     *
+     * Use with calendarSystemsList() to populate selection lists of available
+     * calendar systems.
+     *
+     * @param calendarSystem the specific calendar type to return the label for
+     * @param locale the locale to use for the label, defaults to global
+     * @return label for calendar
+     */
+    static QString calendarLabel(KLocale::CalendarSystem calendarSystem, const KLocale *locale = KGlobal::locale());
+
+    //KDE5 Remove
+    /**
+     * @since 4.7
+     *
+     * Returns the Calendar System enum value for a given Calendar Type,
+     * e.g. KLocale::QDateCalendar for "gregorian"
+     *
+     * @param calendarType the calendar type to convert
+     * @return calendar system for calendar type
+     */
+    static KLocale::CalendarSystem calendarSystem(const QString &calendarType);
+
+    //KDE5 remove
+    /**
+     * @since 4.7
+     *
+     * Returns the deprecated Calendar Type for a given Calendar System enum value,
+     * e.g. "gregorian" for KLocale::QDateCalendar
+     *
+     * @param calendarSystem the calendar system to convert
+     * @return calendar type for calendar system
+     */
+    static QString calendarType(KLocale::CalendarSystem calendarSystem);
+#endif
+
+    KCalendarSystem(const KLocale *locale = 0);
+
+#if 0
+    /**
+     * Constructor of abstract calendar class. This will be called by derived classes.
+     *
+     * @param config a configuration file with a 'KCalendarSystem %calendarName' group detailing
+     *               locale-related preferences (such as era options).  The global config is used
+                     if null.
+     * @param locale locale to use for translations. The global locale is used if null.
+     */
+    explicit KCalendarSystem(const KSharedConfig::Ptr config, const KLocale *locale = 0);
+#endif
+
+    virtual ~KCalendarSystem();
+
+#if 0
+    //KDE5 make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns the Calendar System type of the KCalendarSystem object
+     *
+     * @return type of calendar system
+     */
+    KLocale::CalendarSystem calendarSystem() const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a localized label to display for the current Calendar System type.
+     *
+     * @return localized label for this Calendar System
+     */
+    QString calendarLabel() const;
+
+    /**
+     * Returns a QDate holding the epoch of the calendar system.  Usually YMD
+     * of 1/1/1, access the returned QDates method toJulianDay() if you
+     * require the actual Julian day number.  Note: a particular calendar
+     * system implementation may not include the epoch in its supported range,
+     * or the calendar system may be proleptic in which case it supports dates
+     * before the epoch.
+     *
+     * @see KCalendarSystem::earliestValidDate
+     * @see KCalendarSystem::latestValidDate
+     * @see KCalendarSystem::isProleptic
+     * @see KCalendarSystem::isValid
+     *
+     * @return epoch of calendar system
+     */
+    virtual QDate epoch() const;
+
+    /**
+     * Returns the earliest date valid in this calendar system implementation.
+     *
+     * If the calendar system is proleptic then this may be before epoch.
+     *
+     * @see KCalendarSystem::epoch
+     * @see KCalendarSystem::latestValidDate
+     *
+     * @return date the earliest valid date
+     */
+    virtual QDate earliestValidDate() const;
+
+    /**
+     * Returns the latest date valid in this calendar system implementation.
+     *
+     * @see KCalendarSystem::epoch
+     * @see KCalendarSystem::earliestValidDate
+     *
+     * @return date the latest valid date
+     */
+    virtual QDate latestValidDate() const;
+
+    /**
+     * Returns whether a given date is valid in this calendar system.
+     *
+     * @param year the year portion of the date to check
+     * @param month the month portion of the date to check
+     * @param day the day portion of the date to check
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    virtual bool isValid(int year, int month, int day) const = 0;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.4
+     *
+     * Returns whether a given date is valid in this calendar system.
+     *
+     * @param year the year portion of the date to check
+     * @param dayOfYear the day of year portion of the date to check
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    bool isValid(int year, int dayOfYear) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns whether a given date is valid in this calendar system.
+     *
+     * @param eraName the Era Name portion of the date to check
+     * @param yearInEra the Year In Era portion of the date to check
+     * @param month the Month portion of the date to check
+     * @param day the Day portion of the date to check
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    bool isValid(const QString &eraName, int yearInEra, int month, int day) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.4
+     *
+     * Returns whether a given date is valid in this calendar system.
+     *
+     * @param year the year portion of the date to check
+     * @param isoWeekNumber the ISO week portion of the date to check
+     * @param dayOfIsoWeek the day of week portion of the date to check
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    bool isValidIsoWeekDate(int year, int isoWeekNumber, int dayOfIsoWeek) const;
+
+    /**
+     * Returns whether a given date is valid in this calendar system.
+     *
+     * @param date the date to check
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    virtual bool isValid(const QDate &date) const;
+
+    /**
+     * Changes the date's year, month and day. The range of the year, month
+     * and day depends on which calendar is being used.  All years entered
+     * are treated literally, i.e. no Y2K translation is applied to years
+     * entered in the range 00 to 99.  Replaces setYMD.
+     *
+     * @param date date to change
+     * @param year year
+     * @param month month number
+     * @param day day of month
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    virtual bool setDate(QDate &date, int year, int month, int day) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.4
+     *
+     * Set a date using the year number and day of year number only.
+     *
+     * @param date date to change
+     * @param year year
+     * @param dayOfYear day of year
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    bool setDate(QDate &date, int year, int dayOfYear) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Set a date using the era, year in era number, month and day
+     *
+     * @param date date to change
+     * @param eraName Era string
+     * @param yearInEra Year In Era number
+     * @param month Month number
+     * @param day Day Of Month number
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    bool setDate(QDate &date, QString eraName, int yearInEra, int month, int day) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.4
+     *
+     * Set a date using the year number, ISO week number and day of week number.
+     *
+     * @param date date to change
+     * @param year year
+     * @param isoWeekNumber ISO week of year
+     * @param dayOfIsoWeek day of week Mon..Sun (1..7)
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    bool setDateIsoWeek(QDate &date, int year, int isoWeekNumber, int dayOfIsoWeek) const;
+
+    /**
+     * @deprecated Use setDate() instead
+     *
+     * Some implementations reject year range 00 to 99, but extended date
+     * ranges now require these to be accepted.  Equivalent in QDate is
+     * obsoleted.
+     *
+     * Changes the date's year, month and day. The range of the year, month
+     * and day depends on which calendar is being used.
+     *
+     * @param date Date to change
+     * @param y Year
+     * @param m Month number
+     * @param d Day of month
+     * @return true if the date is valid; otherwise returns false.
+     */
+    KDE_DEPRECATED virtual bool setYMD(QDate &date, int y, int m, int d) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns the year, month and day portion of a given date in the current calendar system
+     *
+     * @param date date to get year, month and day for
+     * @param year year number returned in this variable
+     * @param month month number returned in this variable
+     * @param day day of month returned in this variable
+     */
+    void getDate(const QDate date, int *year, int *month, int *day) const;
+
+    /**
+     * Returns the year portion of a given date in the current calendar system
+     *
+     * @param date date to return year for
+     * @return year, 0 if input date is invalid
+     */
+    virtual int year(const QDate &date) const;
+#endif
+    /**
+     * Returns the month portion of a given date in the current calendar system
+     *
+     * @param date date to return month for
+     * @return month of year, 0 if input date is invalid
+     */
+    int month(const QDate &date) const {return 0;}
+
+    /**
+     * Returns the day portion of a given date in the current calendar system
+     *
+     * @param date date to return day for
+     * @return day of the month, 0 if input date is invalid
+     */
+     int day(const QDate &date) const {return 0;}
+#if 0
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns the Era Name portion of a given date in the current calendar system,
+     * for example "AD" or "Anno Domini" for the Gregorian calendar and Christian Era.
+     *
+     * @param date date to return Era Name for
+     * @param format format to return, either short or long
+     * @return era name, empty string if input date is invalid
+     */
+    QString eraName(const QDate &date, StringFormat format = ShortFormat) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns the Era Year portion of a given date in the current
+     * calendar system, for example "2000 AD" or "Heisei 22".
+     *
+     * @param date date to return Era Year for
+     * @param format format to return, either short or long
+     * @return era name, empty string if input date is invalid
+     */
+    QString eraYear(const QDate &date, StringFormat format = ShortFormat) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns the Year In Era portion of a given date in the current calendar
+     * system, for example 1 for "1 BC".
+     *
+     * @param date date to return Year In Era for
+     * @return Year In Era, -1 if input date is invalid
+     */
+    int yearInEra(const QDate &date) const;
+#endif
+
+    virtual QDate addYears(const QDate &date, int nyears) const { return date.addYears(nyears); }
+    virtual QDate addMonths(const QDate &date, int nmonths) const { return date.addMonths(nmonths); }
+    virtual QDate addDays(const QDate &date, int ndays) const { return date.addDays(ndays); }
+
+#if 0
+    //KDE5 make virtual?
+    /**
+     * Returns the difference between two dates in years, months and days.
+     * The difference is always caculated from the earlier date to the later
+     * date in year, month and day order, with the @p direction parameter
+     * indicating which direction the difference is applied from the @p toDate.
+     *
+     * For example, the difference between 2010-06-10 and 2012-09-5 is 2 years,
+     * 2 months and 26 days.  Note that the difference between two last days of
+     * the month is always 1 month, e.g. 2010-01-31 to 2010-02-28 is 1 month
+     * not 28 days.
+     *
+     * @param fromDate The date to start from
+     * @param toDate The date to end at
+     * @param yearsDiff Returns number of years difference
+     * @param monthsDiff Returns number of months difference
+     * @param daysDiff Returns number of days difference
+     * @param direction Returns direction of difference, 1 if fromDate <= toDate, -1 otherwise
+     */
+    void dateDifference(const QDate &fromDate, const QDate &toDate,
+                        int *yearsDiff, int *monthsDiff, int *daysDiff, int *direction) const;
+
+    //KDE5 make virtual?
+    /**
+    * Returns the difference between two dates in completed calendar years.
+    * The returned value will be negative if @p fromDate > @p toDate.
+    *
+    * For example, the difference between 2010-06-10 and 2012-09-5 is 2 years.
+    *
+    * @param fromDate The date to start from
+    * @param toDate The date to end at
+    * @return The number of years difference
+    */
+    int yearsDifference(const QDate &fromDate, const QDate &toDate) const;
+
+    //KDE5 make virtual?
+    /**
+     * Returns the difference between two dates in completed calendar months
+     * The returned value will be negative if @p fromDate > @p toDate.
+     *
+     * For example, the difference between 2010-06-10 and 2012-09-5 is 26 months.
+     * Note that the difference between two last days of the month is always 1
+     * month, e.g. 2010-01-31 to 2010-02-28 is 1 month not 28 days.
+     *
+     * @param fromDate The date to start from
+     * @param toDate The date to end at
+     * @return The number of months difference
+     */
+    int monthsDifference(const QDate &fromDate, const QDate &toDate) const;
+
+    //KDE5 make virtual?
+    /**
+     * Returns the difference between two dates in days
+     * The returned value will be negative if @p fromDate > @p toDate.
+     *
+     * @param fromDate The date to start from
+     * @param toDate The date to end at
+     * @return The number of days difference
+     */
+    int daysDifference(const QDate &fromDate, const QDate &toDate) const;
+
+    /**
+     * Returns number of months in the given year
+     *
+     * @param date the date to obtain year from
+     * @return number of months in the year, -1 if input date invalid
+     */
+    virtual int monthsInYear(const QDate &date) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns number of months in the given year
+     *
+     * @param year the required year
+     * @return number of months in the year, -1 if input date invalid
+     */
+    int monthsInYear(int year) const;
+
+    /**
+     * Returns the number of localized weeks in the given year.
+     *
+     * @param date the date to obtain year from
+     * @return number of weeks in the year, -1 if input date invalid
+     */
+    virtual int weeksInYear(const QDate &date) const;
+
+    //KDE5 Merge with virtual weeksInYear with default
+    /**
+     * @since 4.7
+     *
+     * Returns the number of Weeks in a year using the required Week Number System.
+     *
+     * Unless you specifically want a particular Week Number System (e.g. ISO Weeks)
+     * you should use the localized number of weeks provided by weeksInYear().
+     *
+     * @see week()
+     * @see formatDate()
+     * @param date the date to obtain year from
+     * @param weekNumberSystem the week number system to use
+     * @return number of weeks in the year, -1 if  date invalid
+     */
+    int weeksInYear(const QDate &date, KLocale::WeekNumberSystem weekNumberSystem) const;
+
+    /**
+     * Returns the number of localized weeks in the given year.
+     *
+     * @param year the year
+     * @return number of weeks in the year, -1 if input date invalid
+     */
+    virtual int weeksInYear(int year) const;
+
+    //KDE5 Merge with virtual weeksInYear with default
+    /**
+     * @since 4.7
+     *
+     * Returns the number of Weeks in a year using the required Week Number System.
+     *
+     * Unless you specifically want a particular Week Number System (e.g. ISO Weeks)
+     * you should use the localized number of weeks provided by weeksInYear().
+     *
+     * @see week()
+     * @see formatDate()
+     * @param year the year
+     * @param weekNumberSystem the week number system to use
+     * @return number of weeks in the year, -1 if  date invalid
+     */
+    int weeksInYear(int year, KLocale::WeekNumberSystem weekNumberSystem) const;
+
+    /**
+     * Returns the number of days in the given year.
+     *
+     * @param date the date to obtain year from
+     * @return number of days in year, -1 if input date invalid
+     */
+    virtual int daysInYear(const QDate &date) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns the number of days in the given year.
+     *
+     * @param year the year
+     * @return number of days in year, -1 if input date invalid
+     */
+    int daysInYear(int year) const;
+
+    /**
+     * Returns the number of days in the given month.
+     *
+     * @param date the date to obtain month from
+     * @return number of days in month, -1 if input date invalid
+     */
+    virtual int daysInMonth(const QDate &date) const;
+
+    //KDE5 make virtual?
+    /**
+     * @since 4.5
+     *
+     * Returns the number of days in the given month.
+     *
+     * @param year the year the month is in
+     * @param month the month
+     * @return number of days in month, -1 if input date invalid
+     */
+    int daysInMonth(int year, int month) const;
+
+    /**
+     * Returns the number of days in the given week.
+     *
+     * @param date the date to obtain week from
+     * @return number of days in week, -1 if input date invalid
+     */
+    virtual int daysInWeek(const QDate &date) const;
+
+    /**
+     * Returns the day number of year for the given date
+     *
+     * The days are numbered 1..daysInYear()
+     *
+     * @param date the date to obtain day from
+     * @return day of year number, -1 if input date not valid
+     */
+    virtual int dayOfYear(const QDate &date) const;
+#endif
+
+    /**
+     * Returns the weekday number for the given date
+     *
+     * The weekdays are numbered 1..7 for Monday..Sunday.
+     *
+     * This value is @em not affected by the value of weekStartDay()
+     *
+     * @param date the date to obtain day from
+     * @return day of week number, -1 if input date not valid
+     */
+    int dayOfWeek(const QDate &date) const {return 0;}
+
+    //KDE5 Make virtual?
+    /**
+     * Returns the localized Week Number for the date.
+     *
+     * This may be ISO, US, or any other supported week numbering scheme.  If
+     * you specifically require the ISO Week or any other scheme, you should use
+     * the week(KLocale::WeekNumberSystem) form.
+     *
+     * If the date falls in the last week of the previous year or the first
+     * week of the following year, then the yearNum returned will be set to the
+     * appropriate year.
+     *
+     * @see weeksInYear()
+     * @see formatDate()
+     * @param date the date to obtain week from
+     * @param yearNum returns the year the date belongs to
+     * @return localized week number, -1 if input date invalid
+     */
+    int week(const QDate &date, int *yearNum = 0) const {return 0;}
+
+#if 0
+    //KDE5 Make virtual?
+    /**
+     * Returns the Week Number for the date in the required Week Number System.
+     *
+     * Unless you want a specific Week Number System (e.g. ISO Week), you should
+     * use the localized Week Number form of week().
+     *
+     * If the date falls in the last week of the previous year or the first
+     * week of the following year, then the yearNum returned will be set to the
+     * appropriate year.
+     *
+     * Technically, the ISO Week Number only applies to the ISO/Gregorian Calendar
+     * System, but the same rules will be applied to the current Calendar System.
+     *
+     * @see weeksInYear()
+     * @see formatDate()
+     * @param date the date to obtain week from
+     * @param weekNumberSystem the Week Number System to use
+     * @param yearNum returns the year the date belongs to
+     * @return week number, -1 if input date invalid
+     */
+    int week(const QDate &date, KLocale::WeekNumberSystem weekNumberSystem, int *yearNum = 0) const;
+
+    /**
+     * Returns whether a given year is a leap year.
+     *
+     * Input year must be checked for validity in current Calendar System prior to calling, no
+     * validity checking performed in this routine, behaviour is undefined in invalid case.
+     *
+     * @param year the year to check
+     * @return @c true if the year is a leap year, @c false otherwise
+     */
+    virtual bool isLeapYear(int year) const = 0;
+
+    /**
+     * Returns whether a given date falls in a leap year.
+     *
+     * Input date must be checked for validity in current Calendar System prior to calling, no
+     * validity checking performed in this routine, behaviour is undefined in invalid case.
+     *
+     * @param date the date to check
+     * @return @c true if the date falls in a leap year, @c false otherwise
+     */
+    virtual bool isLeapYear(const QDate &date) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the first day of the year
+     *
+     * @param year The year to return the date for
+     * @return The first day of the year
+     */
+    QDate firstDayOfYear(int year) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the last day of the year
+     *
+     * @param year The year to return the date for
+     * @return The last day of the year
+     */
+    QDate lastDayOfYear(int year) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the first day of the year
+     *
+     * @param date The year to return the date for, defaults to today
+     * @return The first day of the year
+     */
+    QDate firstDayOfYear(const QDate &date = QDate::currentDate()) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the last day of the year
+     *
+     * @param date The year to return the date for, defaults to today
+     * @return The last day of the year
+     */
+    QDate lastDayOfYear(const QDate &date = QDate::currentDate()) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the first day of the month
+     *
+     * @param year The year to return the date for
+     * @param month The month to return the date for
+     * @return The first day of the month
+     */
+    QDate firstDayOfMonth(int year, int month) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the last day of the month
+     *
+     * @param year The year to return the date for
+     * @param month The month to return the date for
+     * @return The last day of the month
+     */
+    QDate lastDayOfMonth(int year, int month) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the first day of the month
+     *
+     * @param date The month to return the date for, defaults to today
+     * @return The first day of the month
+     */
+    QDate firstDayOfMonth(const QDate &date = QDate::currentDate()) const;
+
+    //KDE5 Make virtual?
+    /**
+     * @since 4.6
+     *
+     * Returns a QDate containing the last day of the month
+     *
+     * @param date The month to return the date for, defaults to today
+     * @return The last day of the month
+     */
+    QDate lastDayOfMonth(const QDate &date = QDate::currentDate()) const;
+#endif
+
+    virtual QString monthName(int month, int year, MonthNameFormat format = LongName) const { return monthName(QDate(year, month, 1), format); }
+    virtual QString monthName(const QDate &date, MonthNameFormat format = LongName) const { return m_locale->formatDate(date, KLocale::MonthName); }
+
+    virtual QString weekDayName(int weekDay, WeekDayNameFormat format = LongDayName) const { return QString::number(weekDay); }
+    virtual QString weekDayName(const QDate &date, WeekDayNameFormat format = LongDayName) const { return weekDayName(date.weekNumber(), format); }
+
+#if 0
+    //KDE5 make protected or remove?
+    /**
+     * @deprecated for internal use only
+     *
+     * Converts a year literal of a part of a string into a integer starting at the beginning of the string
+     *
+     * @param sNum The string to parse
+     * @param iLength The number of QChars used, and 0 if no valid symbols was found in the string
+     * @return An integer corresponding to the year
+     */
+    virtual int yearStringToInteger(const QString &sNum, int &iLength) const;
+
+    //KDE5 make protected or remove?
+    /**
+     * @deprecated for internal use only
+     *
+     * Converts a month literal of a part of a string into a integer starting at the beginning of the string
+     *
+     * @param sNum The string to parse
+     * @param iLength The number of QChars used, and 0 if no valid symbols was found in the string
+     * @return An integer corresponding to the month
+     */
+    virtual int monthStringToInteger(const QString &sNum, int &iLength) const;
+
+    //KDE5 make protected or remove?
+    /**
+     * @deprecated for internal use only
+     *
+     * Converts a day literal of a part of a string into a integer starting at the beginning of the string
+     *
+     * @param sNum The string to parse
+     * @param iLength The number of QChars used, and 0 if no valid symbols was found in the string
+     * @return An integer corresponding to the day
+     */
+    virtual int dayStringToInteger(const QString &sNum, int &iLength) const;
+#endif
+
+    virtual QString formatDate(const QDate &fromDate, KLocale::DateFormat toFormat = KLocale::LongDate) const;
+    virtual QString formatDate(const QDate &fromDate, const QString &toFormat, KLocale::DateTimeFormatStandard formatStandard = KLocale::KdeFormat) const;
+    virtual QString formatDate(const QDate &fromDate, const QString &toFormat, KLocale::DigitSet digitSet, KLocale::DateTimeFormatStandard formatStandard = KLocale::KdeFormat) const;
+    virtual QString formatDate(const QDate &date, KLocale::DateTimeComponent component, KLocale::DateTimeComponentFormat format = KLocale::DefaultComponentFormat, KLocale::WeekNumberSystem weekNumberSystem = KLocale::DefaultWeekNumber) const;
+
+    virtual QDate readDate(const QString &str, bool *ok = 0) const;
+    virtual QDate readDate(const QString &str, KLocale::ReadDateFlags flags, bool *ok = 0) const;
+    virtual QDate readDate(const QString &dateString, const QString &dateFormat, bool *ok = 0) const;
+    virtual QDate readDate(const QString &dateString, const QString &dateFormat, bool *ok, KLocale::DateTimeFormatStandard formatStandard) const;
+
+#if 0
+    //KDE5 Make virtual
+    /**
+     * @since 4.6
+     *
+     * Returns the Short Year Window Start Year for the current Calendar System.
+     *
+     * Use this function to get the Start Year for the Short Year Window to be
+     * applied when 2 digit years are entered for a Short Year input format,
+     * e.g. if the Short Year Window Start Year is 1930, then the input Short
+     * Year value of 40 is interpreted as 1940 and the input Short Year value
+     * of 10 is interpreted as 2010.
+     *
+     * The Short Year Window is only ever applied when reading the Short Year
+     * format and not the Long Year format, i.e. KLocale::ShortFormat or '%y'
+     * only and not KLocale::LongFormat or '%Y'.
+     *
+     * The Start Year 0 effectively means not to use a Short Year Window
+     *
+     * Each Calendar System requires a different Short Year Window as they have
+     * different epochs. The Gregorian Short Year Window usually pivots around
+     * the year 2000, whereas the Hebrew Short Year Window usually pivots around
+     * the year 5000.
+     *
+     * This value must always be used when evaluating user input Short Year
+     * strings.
+     *
+     * @see KLocale::shortYearWindowStartYear
+     * @see KLocale::applyShortYearWindow
+     * @return the short year window start year
+     */
+    int shortYearWindowStartYear() const;
+
+    //KDE5 Make virtual
+    /**
+     * @since 4.6
+     *
+     * Returns the Year Number after applying the Year Window.
+     *
+     * If the @p inputYear is between 0 and 99, then apply the Year Window and
+     * return the calculated Year Number.
+     *
+     * If the @p inputYear is not between 0 and 99, then the original Year Number
+     * is returned.
+     *
+     * @see KLocale::setYearWindowOffset
+     * @see KLocale::yearWindowOffset
+     * @param inputYear the year number to apply the year window to
+     * @return the year number after applying the year window
+     */
+    int applyShortYearWindow(int inputYear) const;
+
+    /**
+     * Use this to determine which day is the first day of the week.
+     *
+     * Uses the calendar system's internal locale set when the instance was
+     * created, which ensures that the correct calendar system and locale
+     * settings are respected, which would not occur in some cases if using
+     * the global locale.  Defaults to global locale.
+     *
+     * @see KLocale::weekStartDay
+     *
+     * @return an integer (Monday = 1, ..., Sunday = 7)
+     */
+    virtual int weekStartDay() const;
+
+    /**
+     * @deprecated use KLocale::weekDayOfPray() instead
+     *
+     * Returns the day of the week traditionally associated with religious
+     * observance for this calendar system.  Note this may not be accurate
+     * for the users locale, e.g. Gregorian calendar used in non-Christian
+     * countries, in use cases where this could be an issue it is recommended
+     * to use KLocale::weekDayOfPray() instead.
+     *
+     * @return day number (None = 0, Monday = 1, ..., Sunday = 7)
+     */
+    KDE_DEPRECATED virtual int weekDayOfPray() const = 0;
+
+    /**
+     * Returns whether the calendar is lunar based.
+     *
+     * @return @c true if the calendar is lunar based, @c false if not
+     */
+    virtual bool isLunar() const = 0;
+
+    /**
+     * Returns whether the calendar is lunisolar based.
+     *
+     * @return @c true if the calendar is lunisolar based, @c false if not
+     */
+    virtual bool isLunisolar() const = 0;
+
+    /**
+     * Returns whether the calendar is solar based.
+     *
+     * @return @c true if the calendar is solar based, @c false if not
+     */
+    virtual bool isSolar() const = 0;
+
+    /**
+     * Returns whether the calendar system is proleptic, i.e. whether dates
+     * before the epoch are supported.
+     *
+     * @see KCalendarSystem::epoch
+     *
+     * @return @c true if the calendar system is proleptic, @c false if not
+     */
+    virtual bool isProleptic() const = 0;
+
+protected:
+
+    /**
+     * Internal method to convert a Julian Day number into the YMD values for
+     * this calendar system.
+     *
+     * All calendar system implementations MUST implement julianDayToDate and
+     * dateToJulianDay methods as all other methods can be expressed as
+     * functions of these.  Does no internal validity checking.
+     *
+     * @see KCalendarSystem::dateToJulianDay
+     *
+     * @param jd Julian day number to convert to date
+     * @param year year number returned in this variable
+     * @param month month number returned in this variable
+     * @param day day of month returned in this variable
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    virtual bool julianDayToDate(int jd, int &year, int &month, int &day) const = 0;
+
+    /**
+     * Internal method to convert YMD values for this calendar system into a
+     * Julian Day number.
+     *
+     * All calendar system implementations MUST implement julianDayToDate and
+     * dateToJulianDay methods as all other methods can be expressed as
+     * functions of these.  Does no internal validity checking.
+     *
+     * @see KCalendarSystem::julianDayToDate
+     *
+     * @param year year number
+     * @param month month number
+     * @param day day of month
+     * @param jd Julian day number returned in this variable
+     * @return @c true if the date is valid, @c false otherwise
+     */
+    virtual bool dateToJulianDay(int year, int month, int day, int &jd) const = 0;
+
+    /**
+     * Returns the locale used for translations and formats for this
+     * calendar system instance.  This allows a calendar system instance to be
+     * independent of the global translations and formats if required.  All
+     * implementations must refer to this locale.
+     *
+     * Only for internal calendar system use; if public access is required then
+     * provide public methods only for those methods actually required.  Any
+     * app that creates an instance with its own locale overriding global will
+     * have the original handle to the locale and can manipulate it that way if
+     * required, e.g. to change default date format.  Only expose those methods
+     * that library widgets require access to internally.
+     *
+     * @see KCalendarSystem::formatDate
+     * @see KLocale::formatDate
+     * @see KCalendarSystem::weekStartDay
+     * @see KLocale::weekStartDay
+     * @see KCalendarSystem::readDate
+     * @see KLocale::readDate
+     *
+     * @return locale to use
+     */
+    const KLocale *locale() const;
+
+    /**
+     * @deprecated for internal use only
+     *
+     * Sets the maximum number of months in a year
+     *
+     * Only for internal calendar system use
+     */
+    KDE_DEPRECATED void setMaxMonthsInYear(int maxMonths);
+
+    /**
+     * @deprecated for internal use only
+     *
+     * Sets the maximum number of days in a week
+     *
+     * Only for internal calendar system use
+     */
+    KDE_DEPRECATED void setMaxDaysInWeek(int maxDays);
+
+    /**
+     * @deprecated for internal use only
+     *
+     * @since 4.4
+     *
+     * Sets if Calendar System has Year 0 or not
+     *
+     * Only for internal calendar system use
+     */
+    KDE_DEPRECATED void setHasYear0(bool hasYear0);
+
+    /**
+     * Constructor of abstract calendar class. This will be called by derived classes.
+     *
+     * @param dd derived private d-pointer.
+     * @param config a configuration file with a 'KCalendarSystem %calendarName' group detailing
+     *               locale-related preferences (such as era options).  The global config is used
+                     if null.
+     * @param locale locale to use for translations. The global locale is used if null.
+     */
+    KCalendarSystem(KCalendarSystemPrivate &dd,
+                    const KSharedConfig::Ptr config = KSharedConfig::Ptr(),
+                    const KLocale *locale = 0);
+#endif
+private:
+    const KLocale *m_locale;
+};
+
+
+#endif
diff --git a/sheets/kfind.h b/sheets/kfind.h
new file mode 100644
index 00000000000..772ce46a453
--- /dev/null
+++ b/sheets/kfind.h
@@ -0,0 +1,74 @@
+#ifndef FAKE_KFIND_H
+#define FAKE_KFIND_H
+
+#include <QObject>
+#include <QWidget>
+#include <QDialog>
+
+class Q_DECL_EXPORT KFind : public QObject
+{
+    Q_OBJECT
+
+public:
+
+    /// the options
+    enum Options
+    {
+        WholeWordsOnly = 1,     ///< Match whole words only.
+        FromCursor = 2,         ///< Start from current cursor position.
+        SelectedText = 4,       ///< Only search selected area.
+        CaseSensitive = 8,      ///< Consider case when matching.
+        FindBackwards = 16,     ///< Go backwards.
+        RegularExpression = 32, ///< Interpret the pattern as a regular expression.
+        FindIncremental = 64,   ///< Find incremental.
+        // Note that KReplaceDialog uses 256 and 512
+        // User extensions can use boolean options above this value.
+        MinimumUserOption = 65536 ///< user options start with this bit
+    };
+#if 0
+    Q_DECLARE_FLAGS(SearchOptions, Options)
+#endif
+
+    KFind(const QString &pattern, long options, QWidget *parent) {}
+    KFind(const QString &pattern, long options, QWidget *parent, QWidget* findDialog) {}
+    virtual ~KFind() {}
+
+    enum Result { NoMatch, Match };
+
+    bool needData() const { return false; }
+    void setData( const QString& data, int startPos = -1 ) {}
+    void setData( int id, const QString& data, int startPos = -1 ) {}
+    Result find() { return NoMatch; }
+    long options() const{ return 0; }
+    virtual void setOptions( long options ) {}
+    QString pattern() const{ return QString(); }
+    void setPattern( const QString& pattern ) {}
+    int numMatches() const{ return 0; }
+    virtual void resetCounts() {}
+    virtual bool validateMatch( const QString & text, int index, int matchedlength ) { return false; }
+    virtual bool shouldRestart( bool forceAsking = false, bool showNumMatches = true ) const { return false; }
+    static int find( const QString &text, const QString &pattern, int index, long options, int *matchedlength ) { return 0; }
+    static int find( const QString &text, const QRegExp &pattern, int index, long options, int *matchedlength ) { return 0; }
+    virtual void displayFinalDialog() const {}
+    QDialog* findNextDialog( bool create = false ) { return 0; }
+    void closeFindNextDialog() {}
+    int index() const { return 0; }
+
+#if 0
+Q_SIGNALS:
+    void highlight(const QString &text, int matchingIndex, int matchedLength);
+    void highlight(int id, int matchingIndex, int matchedLength);
+    void findNext();
+    void optionsChanged();
+    void dialogClosed();
+protected:
+    QWidget* parentWidget() const;
+    QWidget* dialogsParent() const;
+#endif
+};
+
+#if 0
+Q_DECLARE_OPERATORS_FOR_FLAGS(KFind::SearchOptions)
+#endif
+
+#endif
diff --git a/sheets/kfinddialog.h b/sheets/kfinddialog.h
new file mode 100644
index 00000000000..95861f482c8
--- /dev/null
+++ b/sheets/kfinddialog.h
@@ -0,0 +1,30 @@
+#ifndef FAKE_KFINDDIALOG_H
+#define FAKE_KFINDDIALOG_H
+
+#include <QDialog>
+#include <QStringList>
+
+class KFindDialog : public QDialog
+{
+public:
+    explicit KFindDialog( QWidget *parent = 0, long options = 0, const QStringList &findStrings = QStringList(), bool hasSelection = false, bool replaceDialog = false ) : QDialog(parent), m_options(options) {}
+    void setFindHistory( const QStringList &history ) { m_history = history; }
+    QStringList findHistory() const { return m_history; }
+    void setHasSelection( bool hasSelection ) {}
+    void setHasCursor( bool hasCursor ) {}
+    void setSupportsBackwardsFind( bool supports ) {}
+    void setSupportsCaseSensitiveFind( bool supports ) {}
+    void setSupportsWholeWordsFind( bool supports ) {}
+    void setSupportsRegularExpressionFind( bool supports ) {}
+    void setOptions( long options ) { m_options = options; }
+    long options() const { return m_options; }
+    QString pattern() const { return m_pattern; }
+    void setPattern ( const QString &pattern ) { m_pattern = pattern; }
+    QWidget *findExtension() const { return 0; }
+private:
+    QStringList m_history;
+    long m_options;
+    QString m_pattern;
+};
+
+#endif
diff --git a/sheets/klocale.h b/sheets/klocale.h
new file mode 100644
index 00000000000..d2addc9920e
--- /dev/null
+++ b/sheets/klocale.h
@@ -0,0 +1,2140 @@
+#ifndef FAKE_KLOCALE_H
+#define FAKE_KLOCALE_H
+
+#include <QString>
+#include <QStringList>
+#include <QObject>
+#ifndef QT_NO_PRINTER
+#include <QPrinter>
+#endif
+#include <QDate>
+#include <QTime>
+#include <QDateTime>
+#include <QLocale>
+#include <QCoreApplication>
+
+// #include <kdatetime.h>
+#include <klocalizedstring.h>
+
+class KCalendarSystem;
+
+#if 0
+
+#define I18N_NOOP(x) x
+#define I18N_NOOP2(comment,x) x
+
+class KLocale;
+
+
+/**
+ * Wraps KLocale to pure Qt the quick and dirty way to make it
+ * easier to port KDE-applications to Qt-only and keeping both
+ * versions working (what is especially interesting for
+ * translations).
+ */
+class Q_DECL_EXPORT KLocalizedString {
+public:
+    KLocalizedString(const char *msg = "") : m_msg(msg) {
+    }
+    QString toString(KLocale *locale = 0) const {
+        QString s = QObject::tr(m_msg);
+        for(int i = 0; i < m_args.count(); ++i)
+            s = s.arg(m_args[i]);
+        return s;
+    }
+    QString toString(const QString&) { return toString(); }
+    KLocalizedString subs(int a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, base, 'f'));
+        return l;
+    }
+    KLocalizedString subs(uint a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, base, 'f'));
+        return l;
+    }
+    KLocalizedString subs(long a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, base, 'f'));
+        return l;
+    }
+    KLocalizedString subs(ulong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, base, 'f'));
+        return l;
+    }
+    KLocalizedString subs(qlonglong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, base, 'f'));
+        return l;
+    }
+    KLocalizedString subs(qulonglong a, int fieldWidth = 0, int base = 10, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, base, 'f'));
+        return l;
+    }
+    KLocalizedString subs(double a, int fieldWidth = 0, char format = 'g', int precision = -1, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(QString::number(a, format, precision));
+        return l;
+    }
+    KLocalizedString subs(QChar a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(a);
+        return l;
+    }
+    KLocalizedString subs(const QString &a, int fieldWidth = 0, const QChar &fillChar = QLatin1Char(' ')) const {
+        Q_UNUSED(fieldWidth);
+        Q_UNUSED(fillChar);
+        KLocalizedString l(*this);
+        l.m_args.append(a);
+        return l;
+    }
+private:
+    const char *m_msg;
+    QStringList m_args;
+};
+
+inline KLocalizedString ki18n (const char* msg) {
+    return KLocalizedString(msg);
+}
+inline KLocalizedString ki18nc (const char *ctxt, const char *msg) {
+    Q_UNUSED(ctxt);
+    return KLocalizedString(msg);
+}
+inline KLocalizedString ki18np (const char *singular, const char *plural) {
+    Q_UNUSED(singular);
+    return KLocalizedString(plural);
+}
+inline KLocalizedString ki18ncp (const char *ctxt, const char *singular, const char *plural) {
+    Q_UNUSED(ctxt);
+    Q_UNUSED(singular);
+    return KLocalizedString(plural);
+}
+
+// >>>>> Basic calls
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string.
+ * @param text string to be localized
+ * @return localized string
+ */
+inline QString i18n (const char *text)
+{
+  return ki18n(text).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 1 argument.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @return localized string
+ */
+template <typename A1>
+inline QString i18n (const char *text, const A1 &a1)
+{
+  return ki18n(text).subs(a1).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 2 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @return localized string
+ */
+template <typename A1, typename A2>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2)
+{
+  return ki18n(text).subs(a1).subs(a2).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 3 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 4 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 5 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 6 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 7 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 8 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 9 arguments.
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @param a9 ninth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
+inline QString i18n (const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
+{
+  return ki18n(text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
+}
+// <<<<<<< End of basic calls
+
+// >>>>> Context calls
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @return localized string
+ */
+inline QString i18nc (const char *ctxt, const char *text)
+{
+  return ki18nc(ctxt, text).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 1 argument and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @return localized string
+ */
+template <typename A1>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1)
+{
+  return ki18nc(ctxt, text).subs(a1).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 2 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @return localized string
+ */
+template <typename A1, typename A2>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 3 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 4 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 5 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 6 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 7 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 8 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 9 arguments and a context.
+ * @param ctxt context of the string
+ * @param text string to be localized
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @param a9 ninth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
+inline QString i18nc (const char *ctxt, const char *text, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
+{
+  return ki18nc(ctxt, text).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
+}
+// <<<<< End of context calls
+
+// >>>>> Plural calls
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 1 argument using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @return localized string
+ */
+template <typename A1>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1)
+{
+  return ki18np(sing, plur).subs(a1).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 2 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @return localized string
+ */
+template <typename A1, typename A2>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 3 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 4 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 5 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 6 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 7 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 8 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 9 arguments using correct plural form.
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @param a9 ninth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
+inline QString i18np (const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
+{
+  return ki18np(sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
+}
+// <<<<< End of plural calls
+
+// >>>>> Context-plural calls
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 1 argument and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @return localized string
+ */
+template <typename A1>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 2 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @return localized string
+ */
+template <typename A1, typename A2>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 3 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 4 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 5 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 6 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 7 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 8 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).toString();
+}
+// Autogenerated; contact KLocalizedString maintainer for batch changes.
+/**
+ * Returns a localized version of a string with 9 arguments and a context using correct plural form.
+ * @param ctxt context of the string
+ * @param sing string to be localized in singular
+ * @param plur string to be localized in plural
+ * @param a1 first argument
+ * @param a2 second argument
+ * @param a3 third argument
+ * @param a4 fourth argument
+ * @param a5 fifth argument
+ * @param a6 sixth argument
+ * @param a7 seventh argument
+ * @param a8 eighth argument
+ * @param a9 ninth argument
+ * @return localized string
+ */
+template <typename A1, typename A2, typename A3, typename A4, typename A5, typename A6, typename A7, typename A8, typename A9>
+inline QString i18ncp (const char *ctxt, const char *sing, const char *plur, const A1 &a1, const A2 &a2, const A3 &a3, const A4 &a4, const A5 &a5, const A6 &a6, const A7 &a7, const A8 &a8, const A9 &a9)
+{
+  return ki18ncp(ctxt, sing, plur).subs(a1).subs(a2).subs(a3).subs(a4).subs(a5).subs(a6).subs(a7).subs(a8).subs(a9).toString();
+}
+// <<<<< End of context-plural calls
+#endif
+
+class Q_DECL_EXPORT KLocale {
+public:
+  KLocale(const QByteArray &name = QByteArray()) {Q_UNUSED(name)};
+    KLocale(KCalendarSystem *calendar, const QByteArray &name = QByteArray());
+    ~KLocale() {};
+
+    static KLocale* global() {
+        static KLocale* instance = 0;
+        if (!instance) {
+            instance = new KLocale;
+        }
+        return instance;
+    }
+
+    //QString formatNumber(double num, int precision = -1) const { return m_locale.toString(num); }
+    //QString formatNumber(const QString &numStr, bool round = true, int precision = -1) const { return m_locale.toString(num); }
+    //QString formatLong(long num) const { return m_locale.toString(num); }
+    static QString formatNumber(double num, int precision = -1) { return QString::number(num, 'f', precision); }
+    QString formatNumber(const QString &numStr, bool round = true, int precision = -1) const { Q_UNUSED(round); return formatNumber(numStr.toDouble(), precision); }
+    QString formatLong(long num) const { return m_locale.toString((qlonglong)num); }
+
+    double readNumber(const QString &numStr, bool * ok = 0) const
+    {
+        return numStr.toDouble(ok);
+    }
+
+    QString decimalSymbol() const
+    {
+        return ".";
+    }
+    QString thousandsSeparator() const
+    {
+        return ",";
+    }
+
+    QString currencySymbol() const
+    {
+        return QLatin1String("$");
+    }
+
+//    QString formatMoney(double num, const QString &currency = QString(), int precision = -1) const
+//        { return m_locale.toCurrencyString(num, currency); }
+    QString formatMoney(double num, const QString &currency = QString(), int precision = -1) const
+    {
+        QString res = QString::number(num, 'f', precision);
+        if (!currency.isEmpty())
+            res += " " + currency;
+        return res;
+    }
+
+    int pageSize() const
+    {
+#ifndef QT_NO_PRINTER
+        return QPrinter::A4;
+#else
+        return 0;
+#endif
+    }
+#if 0
+    /**
+    * Constructs a KLocale with the given catalog name
+    *
+    * The constructor looks for an entry Language in the group Locale in the
+    * configuration file.
+    *
+    * If no configuration file is specified, it will also look for languages
+    * using the environment variables (KDE_LANG, LC_MESSAGES, LC_ALL, LANG),
+    * as well as the global configuration file. If KLocale is not able to use
+    * any of the specified languages, the default language (en_US) will be
+    * used.
+    *
+    * If you specify a configuration file, it has to be valid until the KLocale
+    * object is destroyed.  Note that a setLocale() will be performed on the
+    * config using the current locale language, which may cause a sync()
+    * and reparseConfiguration() which will save any changes you have made and
+    * load any changes other shared copies have made.
+    *
+    * @param catalog the name of the main language file
+    * @param config  a configuration file with a Locale group detailing
+    *                locale-related preferences (such as language and
+    *                formatting options).
+    */
+    explicit KLocale(const QString& catalog, KSharedConfig::Ptr config = KSharedConfig::Ptr());
+
+    /**
+    * Constructs a KLocale with the given catalog name
+    *
+    * Allows you to override the language and, optionally, the
+    * country of this locale.
+    *
+    * If you specify a configuration file, a setLocale() will be performed on
+    * the config using the current locale language, which may cause a sync()
+    * and reparseConfiguration() which will save any changes you have made.
+    *
+    * @param catalog  the name of the main language file
+    * @param language the ISO Language Code for the locale, e.g. "en" for English
+    * @param country  the ISO Country Code for the locale, e.g. "us" for USA
+    * @param config   a configuration file with a Locale group detailing
+    *                 locale-related preferences (such as language and
+    *                 formatting options).
+    */
+    KLocale(const QString& catalog, const QString &language, const QString &country = QString(),
+            KConfig *config = 0);
+
+    /**
+    * Copy constructor
+    */
+    KLocale(const KLocale & rhs);
+
+    /**
+    * Assignment operator
+    */
+    KLocale& operator= (const KLocale & rhs);
+
+    /**
+    * Destructor
+    */
+    virtual ~KLocale();
+
+    /**
+    * @since 4.5
+    *
+    * Raw translation from a message catalog.
+    * If catalog name is null or empty,
+    * all loaded catalogs are searched for the translation.
+    *
+    * Never use this directly to get message translations. See the i18n and ki18n
+    * family of calls related to KLocalizedString.
+    *
+    * @param catname the catalog name. Must be UTF-8 encoded.
+    * @param msg the message. Must not be null or empty. Must be UTF-8 encoded.
+    * @param lang language in which the translation was found. If no translation
+    *             was found, KLocale::defaultLanguage() is reported. If null,
+    *             the language is not reported.
+    * @param trans raw translation, or original if not found. If no translation
+    *              was found, original message is reported. If null, the
+    *              translation is not reported.
+    *
+    * @see KLocalizedString
+    */
+    void translateRawFrom(const char* catname, const char* msg, QString *lang, QString *trans) const;
+
+    /**
+    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
+    *
+    * @deprecated Use translateRawFrom with null or empty catalog name.
+    */
+    void translateRaw(const char* msg, QString *lang, QString *trans) const;
+
+    /**
+    * @since 4.5
+    *
+    * Raw translation from a message catalog, with given context.
+    * Context + message are used as the lookup key in the catalog.
+    * If catalog name is null or empty,
+    * all loaded catalogs are searched for the translation.
+    *
+    * Never use this directly to get message translations. See i18n* and ki18n*
+    * calls related to KLocalizedString.
+    *
+    * @param catname the catalog name. Must be UTF-8 encoded.
+    * @param ctxt the context. Must not be null. Must be UTF-8 encoded.
+    * @param msg the message. Must not be null or empty. Must be UTF-8 encoded.
+    * @param lang language in which the translation was found. If no translation
+    *             was found, KLocale::defaultLanguage() is reported. If null,
+    *             the language is not reported.
+    * @param trans raw translation, or original if not found. If no translation
+    *              was found, original message is reported. If null, the
+    *              translation is not reported.
+    *
+    * @see KLocalizedString
+    */
+    void translateRawFrom(const char *catname, const char *ctxt, const char *msg, QString *lang, QString *trans) const;
+
+    /**
+    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
+    *
+    * @deprecated Use translateRawFrom with null or empty catalog name.
+    */
+    void translateRaw(const char *ctxt, const char *msg, QString *lang, QString *trans) const;
+
+    /**
+    * @since 4.5
+    *
+    * Raw translation from a message catalog, with given singular/plural form.
+    * Singular form is used as the lookup key in the catalog.
+    * If catalog name is null or empty,
+    * all loaded catalogs are searched for the translation.
+    *
+    * Never use this directly to get message translations. See i18n* and ki18n*
+    * calls related to KLocalizedString.
+    *
+    * @param catname the catalog name. Must be UTF-8 encoded.
+    * @param singular the singular form. Must not be null or empty. Must be UTF-8 encoded.
+    * @param plural the plural form. Must not be null. Must be UTF-8 encoded.
+    * @param n number on which the forms are decided.
+    * @param lang language in which the translation was found. If no translation
+    *             was found, KLocale::defaultLanguage() is reported. If null,
+    *             the language is not reported.
+    * @param trans raw translation, or original if not found. If no translation
+    *              was found, original message is reported (either plural or
+    *              singular, as determined by @p n ). If null, the
+    *              translation is not reported.
+    *
+    * @see KLocalizedString
+    */
+    void translateRawFrom(const char *catname, const char *singular, const char *plural,  unsigned long n,
+                            QString *lang, QString *trans) const;
+
+    /**
+    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
+    *
+    * @deprecated Use translateRawFrom with null or empty catalog name.
+    */
+    void translateRaw(const char *singular, const char *plural,  unsigned long n, QString *lang,
+                    QString *trans) const;
+
+    /**
+    * @since 4.5
+    *
+    * Raw translation from a message catalog, with given context and
+    * singular/plural form.
+    * Context + singular form is used as the lookup key in the catalog.
+    * If catalog name is null or empty,
+    * all loaded catalogs are searched for the translation.
+    *
+    * Never use this directly to get message translations. See i18n* and ki18n*
+    * calls related to KLocalizedString.
+    *
+    * @param catname the catalog name. Must be UTF-8 encoded.
+    * @param ctxt the context. Must not be null. Must be UTF-8 encoded.
+    * @param singular the singular form. Must not be null or empty. Must be UTF-8 encoded.
+    * @param plural the plural form. Must not be null. Must be UTF-8 encoded.
+    * @param n number on which the forms are decided.
+    * @param lang language in which the translation was found. If no translation
+    *             was found, KLocale::defaultLanguage() is reported. If null,
+    *             the language is not reported.
+    * @param trans raw translation, or original if not found. If no translation
+    *              was found, original message is reported (either plural or
+    *              singular, as determined by @p n ). If null, the
+    *              translation is not reported.
+    *
+    * @see KLocalizedString
+    */
+    void translateRawFrom(const char *catname, const char *ctxt, const char *singular, const char *plural,
+                            unsigned long n, QString *lang, QString *trans) const;
+
+    /**
+    * Like translateRawFrom, with implicit lookup through all loaded catalogs.
+    *
+    * @deprecated Use translateRawFrom with null or empty catalog name.
+    */
+    void translateRaw(const char *ctxt, const char *singular, const char *plural, unsigned long n,
+                    QString *lang, QString *trans) const;
+
+    /**
+    * Changes the current encoding.
+    *
+    * @param mibEnum The mib of the preferred codec
+    *
+    * @return True on success.
+    */
+    bool setEncoding(int mibEnum);
+#endif
+
+    enum SignPosition {
+        /**
+        * Put parantheses around the quantity, e.g. "$ (217)"
+        */
+        ParensAround = 0,
+        /**
+        * Prefix the quantity with the sign, e.g. "$ -217"
+        */
+        BeforeQuantityMoney = 1,
+        /**
+        * Suffix the quanitity with the sign, e.g. "$ 217-"
+        */
+        AfterQuantityMoney = 2,
+        /**
+        * Prefix the currency symbol with the sign, e.g. "-$ 217"
+        */
+        BeforeMoney = 3,
+        /**
+        * Suffix the currency symbol with the sign, e.g. "$- 217"
+        */
+        AfterMoney = 4
+    };
+
+    enum DigitSet {
+        ArabicDigits,             /**< 0123456789 (European and some Asian
+                                    languages and western Arabic dialects) */
+        ArabicIndicDigits,        /**< ٠١٢٣٤٥٦٧٨٩ (eastern Arabic dialects) */
+        EasternArabicIndicDigits, /**< ۰۱۲۳۴۵۶۷۸۹ (Persian and Urdu) */
+        DevenagariDigits,         /**< ०१२३४५६७८९ (Hindi) */
+        BengaliDigits,            /**< ০১২৩৪৫৬৭৮৯ (Bengali and  Assamese) */
+        GujaratiDigits,           /**< ૦૧૨૩૪૫૬૭૮૯ (Gujarati) */
+        GurmukhiDigits,           /**< ੦੧੨੩੪੫੬੭੮੯ (Punjabi) */
+        KannadaDigits,            /**< ೦೧೨೩೪೫೬೭೮೯ (Kannada) */
+        KhmerDigits,              /**< ០១២៣៤៥៦៧៨៩ (Khmer) */
+        MalayalamDigits,          /**< ൦൧൨൩൪൫൬൭൮൯ (Malayalam) */
+        OriyaDigits,              /**< ୦୧୨୩୪୫୬୭୮୯ (Oriya) */
+        TamilDigits,              /**< ௦௧௨௩௪௫௬௭௮ (Tamil) */
+        TeluguDigits,             /**< ౦౧౨౩౪౫౬౭౯ (Telugu) */
+        ThaiDigits                /**< ๐๑๒๓๔๕๖๗๘๙ (Thai) */
+    // The following Decimal Digit Sets are defined in Unicode but the associated
+    // languages are not yet translated in KDE, so are not yet enabled.
+    // The script names are taken from the Unicode standard, the associated
+    // languages from Wikipedia.
+    //  BalineseDigits,           /**< ᭐᭑᭒᭓᭔᭕᭖᭗᭘᭙ (Balinese) */
+    //  ChamDigits,               /**< ꩐꩑꩒꩓꩔꩕꩖꩗꩘꩙ (Cham) */
+    //  JavaneseDigits,           /**< ꧐꧑꧒꧓꧔꧕꧖꧗꧘꧙ (Javanese) */
+    //  KayahLiDigits,            /**< ꤀꤁꤂꤃꤄꤅꤆꤇꤈꤉ (Kayah) */
+    //  LaoDigits,                /**< ໐໑໒໓໔໕໖໗໘໙ (Lao) */
+    //  LepchaDigits,             /**< ᱀᱁᱂᱃᱄᱅᱆᱇᱈᱉ (Lepcha) */
+    //  LimbuDigits,              /**< ᥆᥇᥈᥉᥊᥋᥌᥍᥎᥏ (Limbu) */
+    //  MeeteiMayekDigits,        /**< ꯰꯱꯲꯳꯴꯵꯶꯷꯸꯹ (Meitei) */
+    //  MongolianDigits,          /**< ᠐᠑᠒᠓᠔᠕᠖᠗᠘᠙ (Mongolian) */
+    //  MyanmarDigits,            /**< ၀၁၂၃၄၅၆၇၈၉ (Myanmar/Burmese ) */
+    //  MyanmarShanDigits,        /**< ႐႑႒႓႔႕႖႗႘႙ (Shan) */
+    //  NewTaiLueDigits,          /**< ᧐᧑᧒᧓᧔᧕᧖᧗᧘᧙ (Tai Lü) */
+    //  NKoDigits,                /**< ߀߁߂߃߄߅߆߇߈߉ (Mande and N'Ko) */
+    //  OlChikiDigits,            /**< ᱐᱑᱒᱓᱔᱕᱖᱗᱘᱙ (Santali) */
+    //  OsmanyaDigits,            /**< ҠҡҢңҤҥҦҧҨҩ (Somali) */
+    //  SaurashtraDigits,         /**< ꣐꣑꣒꣓꣔꣕꣖꣗꣘꣙ (Saurashtra) */
+    //  SundaneseDigits,          /**< ᮰᮱᮲᮳᮴᮵᮶᮷᮸᮹ (Sundanese) */
+    //  TaiThamDigits,            /**< ᪐᪑᪒᪓᪔᪕᪖᪗᪘᪙ (Tai Lü) */
+    //  TibetanDigits,            /**< ༠༡༢༣༤༥༦༧༨༩ (Tibetan) */
+    //  VaiDigits,                /**< ꘠꘡꘢꘣꘤꘥꘦꘧꘨꘩ (Vai) */
+    };
+
+#if 0
+    /**
+    * @since 4.3
+    *
+    * Convert a digit set identifier to a human readable, localized name.
+    *
+    * @param digitSet the digit set identifier
+    * @param withDigits whether to add the digits themselves to the name
+    *
+    * @return the human readable and localized name of the digit set
+    *
+    * @see DigitSet
+    */
+    QString digitSetToName(DigitSet digitSet, bool withDigits = false) const;
+
+    /**
+    * @since 4.3
+    *
+    * Provides list of all known digit set identifiers.
+    *
+    * @return list of all digit set identifiers
+    * @see DigitSet
+    * @see digitSetToName
+    */
+    QList<DigitSet> allDigitSetsList() const;
+
+    /**
+    * @since 4.3
+    *
+    * Returns the identifier of the digit set used to display numbers.
+    *
+    * @return the digit set identifier
+    * @see DigitSet
+    * @see digitSetToName
+    */
+    DigitSet digitSet() const;
+
+    /**
+    * @since 4.4
+    *
+    * Returns the ISO 4217 Currency Code for the current locale
+    *
+    * @return The default ISO Currency Code used by locale.
+    */
+    QString currencyCode() const;
+
+    /**
+    * @since 4.4
+    *
+    * Returns the Currency Code object for the current locale
+    *
+    * @return The default Currency Code object used by locale.
+    */
+    KCurrencyCode *currency() const;
+#endif
+
+    QString monetaryDecimalSymbol() const { return m_locale.decimalPoint(); }
+    QString monetaryThousandsSeparator() const { return m_locale.groupSeparator(); }
+    QString positiveSign() const { return m_locale.positiveSign(); }
+    QString negativeSign() const { return m_locale.negativeSign(); }
+
+    int fracDigits() const { return decimalPlaces(); }
+    int decimalPlaces() const { return 2; }
+    int monetaryDecimalPlaces() const { return 2; }
+
+    bool positivePrefixCurrencySymbol() const { return true; }
+    bool negativePrefixCurrencySymbol() const { return true; }
+    SignPosition positiveMonetarySignPosition() const { return BeforeMoney; }
+    SignPosition negativeMonetarySignPosition() const { return BeforeMoney; }
+
+#if 0
+    /**
+    * @since 4.3
+    *
+    * Retuns the digit set used to display monetary values.
+    *
+    * @return the digit set identifier
+    * @see DigitSet
+    * @see digitSetToName
+    */
+    DigitSet monetaryDigitSet() const;
+
+    /**
+    * These binary units are used in KDE by the formatByteSize()
+    * functions.
+    *
+    * NOTE: There are several different units standards:
+    * 1) SI  (i.e. metric), powers-of-10.
+    * 2) IEC, powers-of-2, with specific units KiB, MiB, etc.
+    * 3) JEDEC, powers-of-2, used for solid state memory sizing which
+    *    is why you see flash cards labels as e.g. 4GB.  These (ab)use
+    *    the metric units.  Although JEDEC only defines KB, MB, GB, if
+    *    JEDEC is selected all units will be powers-of-2 with metric
+    *    prefixes for clarity in the event of sizes larger than 1024 GB.
+    *
+    * Although 3 different dialects are possible this enum only uses
+    * metric names since adding all 3 different names of essentially the same
+    * unit would be pointless.  Use BinaryUnitDialect to control the exact
+    * units returned.
+    *
+    * @since 4.4
+    * @see binaryUnitDialect
+    */
+    enum BinarySizeUnits {
+        /// Auto-choose a unit such that the result is in the range [0, 1000 or 1024)
+        DefaultBinaryUnits = -1,
+
+        // The first real unit must be 0 for the current implementation!
+        UnitByte,      ///<  B         1 byte
+        UnitKiloByte,  ///<  KiB/KB/kB 1024/1000 bytes.
+        UnitMegaByte,  ///<  MiB/MB/MB 2^20/10^06 bytes.
+        UnitGigaByte,  ///<  GiB/GB/GB 2^30/10^09 bytes.
+        UnitTeraByte,  ///<  TiB/TB/TB 2^40/10^12 bytes.
+        UnitPetaByte,  ///<  PiB/PB/PB 2^50/10^15 bytes.
+        UnitExaByte,   ///<  EiB/EB/EB 2^60/10^18 bytes.
+        UnitZettaByte, ///<  ZiB/ZB/ZB 2^70/10^21 bytes.
+        UnitYottaByte, ///<  YiB/YB/YB 2^80/10^24 bytes.
+        UnitLastUnit = UnitYottaByte
+    };
+
+    /**
+    * This enum chooses what dialect is used for binary units.
+    *
+    * Note: Although JEDEC abuses the metric prefixes and can therefore be
+    * confusing, it has been used to describe *memory* sizes for quite some time
+    * and programs should therefore use either Default, JEDEC, or IEC 60027-2
+    * for memory sizes.
+    *
+    * On the other hand network transmission rates are typically in metric so
+    * Default, Metric, or IEC (which is unambiguous) should be chosen.
+    *
+    * Normally choosing DefaultBinaryUnits is the best option as that uses
+    * the user's selection for units.
+    *
+    * @since 4.4
+    * @see binaryUnitDialect
+    * @see setBinaryUnitDialect
+    */
+    enum BinaryUnitDialect {
+        DefaultBinaryDialect = -1, ///< Used if no specific preference
+        IECBinaryDialect,          ///< KDE Default, KiB, MiB, etc. 2^(10*n)
+        JEDECBinaryDialect,        ///< KDE 3.5 default, KB, MB, etc. 2^(10*n)
+        MetricBinaryDialect,       ///< SI Units, kB, MB, etc. 10^(3*n)
+        LastBinaryDialect = MetricBinaryDialect
+    };
+
+    /**
+    * Converts @p size from bytes to the string representation using the
+    * user's default binary unit dialect.  The default unit dialect is
+    * IEC 60027-2.
+    *
+    * Example:
+    * formatByteSize(1024) returns "1.0 KiB" by default.
+    *
+    * @param  size  size in bytes
+    * @return converted size as a string - e.g. 123.4 KiB , 12.0 MiB
+    * @see BinaryUnitDialect
+    * @todo KDE 5: Remove in favor of overload added in KDE 4.4.
+    */
+    QString formatByteSize(double size) const;
+
+    /**
+    * @since 4.4
+    *
+    * Converts @p size from bytes to the appropriate string representation
+    * using the binary unit dialect @p dialect and the specific units @p specificUnit.
+    *
+    * Example:
+    * formatByteSize(1000, unit, KLocale::BinaryUnitKilo) returns:
+    *   for KLocale::MetricBinaryUnits, "1.0 kB",
+    *   for KLocale::IECBinaryUnits,    "0.9 KiB",
+    *   for KLocale::JEDECBinaryUnits,  "0.9 KB".
+    *
+    * @param size size in bytes
+    * @param precision number of places after the decimal point to use.  KDE uses
+    *        1 by default so when in doubt use 1.
+    * @param dialect binary unit standard to use.  Use DefaultBinaryUnits to
+    *        use the localized user selection unless you need to use a specific
+    *        unit type (such as displaying a flash memory size in JEDEC).
+    * @param specificUnit specific unit size to use in result.  Use
+    *        DefaultBinarySize to automatically select a unit that will return
+    *        a sanely-sized number.
+    * @return converted size as a translated string including the units.
+    *         E.g. "1.23 KiB", "2 GB" (JEDEC), "4.2 kB" (Metric).
+    * @see BinaryUnitDialect
+    */
+    QString formatByteSize(double size, int precision,
+                        BinaryUnitDialect dialect = KLocale::DefaultBinaryDialect,
+                        BinarySizeUnits specificUnit = KLocale::DefaultBinaryUnits) const;
+
+    /**
+    * Returns the user's configured binary unit dialect.
+    * e.g. if MetricBinaryDialect is returned then the values
+    * configured for how much a set of bytes are worth would
+    * be 10^(3*n) and KB (1000 bytes == 1 KB), in this case.
+    *
+    * Will never return DefaultBinaryDialect.
+    *
+    * @since 4.4
+    * @return User's configured binary unit dialect
+    * @see BinaryUnitDialect
+    */
+    BinaryUnitDialect binaryUnitDialect() const;
+
+    /**
+    * Sets @p newDialect to be the default dialect for this locale (and only
+    * this locale).  Newly created KLocale objects will continue to default
+    * to the user's choice.
+    *
+    * @param newDialect the new dialect to set as default for this locale object.
+    * @since 4.4
+    */
+    void setBinaryUnitDialect(BinaryUnitDialect newDialect);
+
+    /**
+    * Given a number of milliseconds, converts that to a string containing
+    * the localized equivalent
+    *
+    * e.g. given formatDuration(60000), returns "1.0 minutes"
+    *
+    * @param mSec Time duration in milliseconds
+    * @return converted duration as a string - e.g. "5.5 seconds" "23.0 minutes"
+    */
+    QString formatDuration(unsigned long mSec) const;
+
+    /**
+    * Given a number of milliseconds, converts that to a pretty string containing
+    * the localized equivalent.
+    *
+    * e.g. given prettyFormatDuration(60001) returns "1 minute"
+    *      given prettyFormatDuration(62005) returns "1 minute and 2 seconds"
+    *      given prettyFormatDuration(90060000) returns "1 day and 1 hour"
+    *
+    * @param mSec Time duration in milliseconds
+    * @return converted duration as a string.
+    *         Units not interesting to the user, for example seconds or minutes when the first
+    *         unit is day, are not returned because they are irrelevant. The same applies for
+    *         seconds when the first unit is hour.
+    * @since 4.2
+    */
+    QString prettyFormatDuration(unsigned long mSec) const;
+
+    /**
+    * @deprecated
+    *
+    * Use this to determine whether nouns are declined in
+    * locale's language. This property should remain
+    * read-only (no setter function)
+    *
+    * @return If nouns are declined
+    */
+    KDE_DEPRECATED bool nounDeclension() const;
+#endif
+
+    enum CalendarSystem {
+        QDateCalendar = 1, /**< KDE Default, hybrid of Gregorian and Julian as used by QDate */
+        //BahaiCalendar = 2, /**< Baha'i Calendar */
+        //BuddhistLunarCalendar = 3, /**< Buddhist Lunar Calendar*/
+        //ChineseCalendar = 4, /**< Chinese Calendar */
+        CopticCalendar = 5, /**< Coptic Calendar as used Coptic Church and some parts of Egypt */
+        EthiopianCalendar = 6, /**< Ethiopian Calendar, aka Ethiopic Calendar */
+        //EthiopianAmeteAlemCalendar = 7, /**< Ethiopian Amete Alem version, aka Ethiopic Amete Alem */
+        GregorianCalendar = 8, /**< Gregorian Calendar, pure proleptic implementation */
+        HebrewCalendar = 9, /**< Hebrew Calendar, aka Jewish Calendar */
+        //HinduCalendar = 10, /**< Hindu Lunar Calendar */
+        //IslamicLunarCalendar = 11, /**< Islamic Lunar Calendar */
+        IslamicCivilCalendar = 12, /**< Islamic Civil Calendar, aka Hijri, not the Lunar Calendar */
+        //IslamicUmAlQuraCalendar = 13, /**< Islamic Lunar Calendar, Um Al Qura varient used in Saudi Arabia */
+        IndianNationalCalendar = 14, /**< Indian National Calendar, not the Lunar Calendar */
+        //Iso8601Calendar = 15, /**< ISO 8601 Standard Calendar */
+        JalaliCalendar = 16, /**< Jalali Calendar, aka Persian or Iranian, also used in Afghanistan */
+        //JalaliBirashkCalendar = 17, /**< Jalali Calendar, Birashk Algorythm variant */
+        //Jalali33YearCalendar = 18, /**< Jalali Calendar, 33 Year cycle variant */
+        JapaneseCalendar= 19, /**< Japanese Calendar, Gregorian calculation using Japanese Era (Nengô) */
+        //JucheCalendar = 20, /**< Juche Calendar, used in North Korea */
+        JulianCalendar = 21, /**< Julian Calendar, as used in Orthodox Churches */
+        MinguoCalendar= 22, /**< Minguo Calendar, aka ROC, Republic of China or Taiwanese */
+        ThaiCalendar = 23 /**< Thai Calendar, aka Buddhist or Thai Buddhist */
+    };
+
+    enum WeekNumberSystem {
+        DefaultWeekNumber = -1, /**< The system locale default */
+        IsoWeekNumber     =  0, /**< ISO Week Number */
+        FirstFullWeek     =  1, /**< Week 1 starts on the first Week Start Day in year ends after 7 days */
+        FirstPartialWeek  =  2, /**< Week 1 starts Jan 1st ends day before first Week Start Day in year */
+        SimpleWeek        =  3  /**< Week 1 starts Jan 1st ends after 7 days */
+    };
+
+    enum DateTimeFormatStandard {
+        KdeFormat,        /**< KDE Standard */
+        PosixFormat,      /**< POSIX Standard */
+        UnicodeFormat     /**< UNICODE Standard (Qt/Java/OSX/Windows) */
+    };
+
+    enum DateTimeParseMode {
+        LiberalParsing   /**< Parse Date/Time liberally.  So long as the
+                            input string contains at least a reconizable
+                            month and day the input will be accepted. */
+        //ModerateParsing, /**< Parse Date/Time with modeate tolerance.
+        //                      The date components in the format must all
+        //                      occur in the input and in the same order,
+        //                      but the spacing and the componants themselves
+        //                      may vary from the strict format. */
+        //StrictParsing    /**< Parse Date/Time strictly to the format. */
+    };
+
+    enum DateTimeComponent {
+        Year          = 0x1,        /**< The Year portion of a date, may be number or name */
+        YearName      = 0x2,        /**< The Year Name portion of a date */
+        Month         = 0x4,        /**< The Month portion of a date, may be number or name */
+        MonthName     = 0x8,        /**< The Month Name portion of a date */
+        Day           = 0x10,       /**< The Day portion of a date, may be number or name */
+        DayName       = 0x20,       /**< The Day Name portion of a date */
+        JulianDay     = 0x40,       /**< The Julian Day of a date */
+        EraName       = 0x80,       /**< The Era Name portion of a date */
+        EraYear       = 0x100,      /**< The Era and Year portion of a date */
+        YearInEra     = 0x200,      /**< The Year In Era portion of a date */
+        DayOfYear     = 0x400,      /**< The Day Of Year portion of a date, may be number or name */
+        DayOfYearName = 0x800,      /**< The Day Of Year Name portion of a date */
+        DayOfWeek     = 0x1000,     /**< The Day Of Week / Weekday portion of a date, may be number or name */
+        DayOfWeekName = 0x2000,     /**< The Day Of Week Name / Weekday Name portion of a date */
+        Week          = 0x4000,     /**< The Week Number portion of a date */
+        WeekYear      = 0x8000,     /**< The Week Year portion of a date */
+        MonthsInYear  = 0x10000,    /**< The Months In Year portion of a date */
+        WeeksInYear   = 0x20000,    /**< The Weeks In Year portion of a date */
+        DaysInYear    = 0x40000,    /**< The Days In Year portion of a date */
+        DaysInMonth   = 0x80000,    /**< The Days In Month portion of a date */
+        DaysInWeek    = 0x100000,   /**< The Days In Week portion of a date */
+        Hour          = 0x200000,   /**< The Hours portion of a date */
+        Minute        = 0x400000,   /**< The Minutes portion of a date */
+        Second        = 0x800000,   /**< The Seconds portion of a date */
+        Millisecond   = 0x1000000,  /**< The Milliseconds portion of a date */
+        DayPeriod     = 0x2000000,  /**< The Day Period portion of a date, e.g. AM/PM */
+        DayPeriodHour = 0x4000000,  /**< The Day Period Hour portion of a date */
+        Timezone      = 0x8000000,  /**< The Time Zone portion of a date, may be offset or name */
+        TimezoneName  = 0x10000000, /**< The Time Zone Name portion of a date */
+        UnixTime      = 0x20000000  /**< The UNIX Time portion of a date */
+    };
+    Q_DECLARE_FLAGS(DateTimeComponents, DateTimeComponent)
+
+    enum DateTimeComponentFormat {
+        DefaultComponentFormat = -1, /**< The system locale default for the componant */
+        ShortNumber = 0,             /**< Number at its natural width, e.g. 2 for the 2nd*/
+        LongNumber,                  /**< Number padded to a required width, e.g. 02 for the 2nd*/
+        //OrdinalNumber                /**< Ordinal number format, e.g. "2nd" for the 2nd */
+        NarrowName = 3,              /**< Narrow text format, may not be unique, e.g. M for Monday */
+        ShortName,                   /**< Short text format, e.g. Mon for Monday */
+        LongName                     /**< Long text format, e.g. Monday for Monday */
+    };
+
+    enum DateFormat {
+        ShortDate,        /**< Locale Short date format, e.g. 08-04-2007 */
+        LongDate,         /**< Locale Long date format, e.g. Sunday 08 April 2007 */
+        FancyShortDate,   /**< Same as ShortDate for dates a week or more ago. For more
+                            recent dates, it is represented as Today, Yesterday, or
+                            the weekday name. */
+        FancyLongDate,    /**< Same as LongDate for dates a week or more ago. For more
+                            recent dates, it is represented as Today, Yesterday, or
+                            the weekday name. */
+        IsoDate,          /**< ISO-8601 Date format YYYY-MM-DD, e.g. 2009-12-31 */
+        IsoWeekDate,      /**< ISO-8601 Week Date format YYYY-Www-D, e.g. 2009-W01-1 */
+        IsoOrdinalDate    /**< ISO-8601 Ordinal Date format YYYY-DDD, e.g. 2009-001 */
+    };
+
+    QString formatDate(const QDate &date, DateFormat format = LongDate) const
+    {
+        switch (format) {
+        case FancyShortDate:
+        case ShortDate: return date.toString(Qt::SystemLocaleShortDate);
+        case FancyLongDate:
+        case LongDate: return date.toString(Qt::SystemLocaleLongDate);
+        case IsoWeekDate:
+        case IsoOrdinalDate:
+        case IsoDate: break;
+        }
+        return date.toString(Qt::ISODate);
+    }
+
+    QString formatDate(const QDate &date, const QString &format) const { return date.toString(format); }
+
+    QString formatDate(const QDate &date, DateTimeComponent component) const
+    {
+        switch (component) {
+            case Year: return QString::number(date.year());
+        case YearName: return QString::number(date.year());
+        case Month: return QString::number(date.month());
+        case MonthName: return QString::number(date.month());
+        case Day: return QString::number(date.day());
+        case DayName: return QString::number(date.day());
+        case JulianDay: return QString::number(date.toJulianDay());
+        case EraName:
+        case EraYear:
+        case YearInEra:
+            break;
+        case DayOfYear: return QString::number(date.dayOfYear());
+        case DayOfYearName: return QString::number(date.dayOfYear());
+        case DayOfWeek: return QString::number(date.dayOfWeek());
+        case DayOfWeekName: return QString::number(date.dayOfWeek());
+        case Week: return QString::number(date.weekNumber());
+        case WeekYear: return QString::number(date.weekNumber());
+        case MonthsInYear: return QString::number(12);
+        case WeeksInYear: return QString::number(53);
+        case DaysInYear: return QString::number(date.daysInYear());
+        case DaysInMonth: return QString::number(date.daysInMonth());
+        case DaysInWeek: return QString::number(7);
+        case Hour:
+        case Minute:
+        case Second:
+        case Millisecond:
+        case DayPeriod:
+        case DayPeriodHour:
+        case Timezone:
+        case TimezoneName:
+        case UnixTime:
+            break;
+        }
+        return QString();
+    }
+
+    QString formatDateTime(const QDateTime &dateTime, DateFormat format = ShortDate, bool includeSecs = false) const
+    {
+        Q_UNUSED(includeSecs);
+        switch (format) {
+        case FancyShortDate:
+        case ShortDate: return dateTime.toString(Qt::SystemLocaleShortDate);
+        case FancyLongDate:
+        case LongDate: return dateTime.toString(Qt::SystemLocaleLongDate);
+        case IsoWeekDate:
+        case IsoOrdinalDate:
+        case IsoDate: break;
+        }
+        return dateTime.toString(Qt::ISODate);
+    }
+    QString formatDateTime(const QDateTime &dateTime, const QString &format) const { return dateTime.toString(format); }
+
+    enum DateTimeFormatOption {
+        TimeZone = 0x01,    /**< Include a time zone string */
+        Seconds  = 0x02     /**< Include the seconds value */
+    };
+    Q_DECLARE_FLAGS(DateTimeFormatOptions, DateTimeFormatOption)
+
+    /* QString formatDateTime(const KDateTime &dateTime, DateFormat format = ShortDate, DateTimeFormatOptions options = 0) const */
+    /* { */
+    /*       switch (format) { */
+    /*       case FancyShortDate: */
+    /*       case ShortDate: return dateTime.toString(Qt::SystemLocaleShortDate); */
+    /*       case FancyLongDate: */
+    /*       case LongDate: return dateTime.toString(Qt::SystemLocaleLongDate); */
+    /*       case IsoWeekDate: */
+    /*       case IsoOrdinalDate: */
+    /*       case IsoDate: break; */
+    /*       } */
+    /*       return dateTime.toString(Qt::ISODate); */
+    /* } */
+
+#if 0
+    /**
+    * Use this to determine whether in dates a possessive form of month
+    * name is preferred ("of January" rather than "January")
+    *
+    * @return If possessive form should be used
+    */
+    bool dateMonthNamePossessive() const;
+#endif
+
+    QString formatTime(const QTime &pTime, bool includeSecs = false, bool isDuration = false) const
+    {
+        Q_UNUSED(includeSecs);
+        Q_UNUSED(isDuration);
+        return m_locale.toString(pTime);
+    }
+
+    enum TimeFormatOption { TimeDefault = 0x0, TimeWithoutSeconds = 0x1, TimeWithoutAmPm    = 0x2, TimeDuration       = 0x6,  TimeFoldHours      = 0xE };
+    Q_DECLARE_FLAGS(TimeFormatOptions, TimeFormatOption)
+
+    QString formatLocaleTime(const QTime &pTime, TimeFormatOptions options = KLocale::TimeDefault) const
+    { Q_UNUSED(options); return m_locale.toString(pTime); }
+
+#if 0
+    /**
+    * @since 4.3
+    *
+    * Returns the identifier of the digit set used to display dates and time.
+    *
+    * @return the digit set identifier
+    * @see DigitSet
+    * @see digitSetToName
+    */
+    DigitSet dateTimeDigitSet() const;
+
+    /**
+    * Use this to determine if the user wants a 12 hour clock.
+    *
+    * @return If the user wants 12h clock
+    */
+    bool use12Clock() const;
+
+    /**
+    * @since 4.6
+    *
+    * Returns the Day Period matching the time given
+    *
+    * @param time the time to return the day period for
+    * @param format the format to return teh day period in
+    * @return the Day Period for the given time
+    */
+    QString dayPeriodText(const QTime &time, DateTimeComponentFormat format = DefaultComponentFormat) const;
+#endif
+
+    int weekStartDay() const { return m_locale.firstDayOfWeek(); }
+    int workingWeekStartDay() const { return Qt::Monday; }
+    int workingWeekEndDay() const { return Qt::Friday; }
+    int weekDayOfPray() const { return Qt::Sunday; }
+
+    const KCalendarSystem* calendar() const { return m_calendar; }
+
+#if 0
+    //KDE_DEPRECATED QString calendarType() const;
+    KLocale::CalendarSystem calendarSystem() const;
+    //KDE_DEPRECATED void setCalendar(const QString & calendarType);
+    void setCalendarSystem(KLocale::CalendarSystem calendarSystem);
+
+    /**
+    * @since 4.6
+    *
+    * Sets the type of Week Number System to use in this Locale
+    *
+    * @see Klocale::WeekNumberSystem
+    * @see weekNumberSystem()
+    * @param weekNumberSystem the Week Number System to use
+    */
+    void setWeekNumberSystem(KLocale::WeekNumberSystem weekNumberSystem);
+
+    //KDE5 remove in favour of const version
+    /**
+    * @since 4.6
+    *
+    * Returns the type of Week Number System used in this Locale
+    *
+    * @see Klocale::WeekNumberSystem
+    * @see setWeekNumberSystem()
+    * @returns the Week Number System used
+    */
+    KLocale::WeekNumberSystem weekNumberSystem();
+
+    /**
+    * @since 4.7
+    *
+    * Returns the type of Week Number System used in this Locale
+    *
+    * @see Klocale::WeekNumberSystem
+    * @see setWeekNumberSystem()
+    * @returns the Week Number System used
+    */
+    KLocale::WeekNumberSystem weekNumberSystem() const;
+#endif
+
+    double readMoney(const QString &numStr, bool * ok = 0) const
+    {
+        QString s = numStr;
+        s.remove(m_locale.currencySymbol());
+        //s.remove(m_locale.groupSeparator());
+        return s.toDouble(ok);
+    }
+
+    QDate readDate(const QString &str, bool* ok = 0) const
+    {
+        QDate date = QDate::fromString(str);
+        if (ok) *ok = date.isValid();
+        return date;
+    }
+
+    QDate readDate(const QString &str, const QString &fmt, bool* ok = 0) const
+    {
+        QDate date = QDate::fromString(str, fmt);
+        if (ok) *ok = date.isValid();
+        return date;
+    }
+    
+    enum ReadDateFlags { NormalFormat = 1, ShortFormat = 2, IsoFormat = 4, IsoWeekFormat = 8, IsoOrdinalFormat = 16 };
+    QDate readDate(const QString &str, ReadDateFlags flags, bool *ok = 0) const
+    {
+        Q_UNUSED(flags);
+        QDate date = QDate::fromString(str);
+        if (ok) *ok = date.isValid();
+        return date;
+    }
+
+    QTime readTime(const QString &str, bool* ok = 0) const
+    {
+        QTime time = QTime::fromString(str);
+        if (ok) *ok = time.isValid();
+        return time;
+    }
+
+    enum ReadTimeFlags { WithSeconds = 0, WithoutSeconds = 1 };
+    QTime readTime(const QString &str, ReadTimeFlags flags, bool *ok = 0) const
+    {
+        Q_UNUSED(flags);
+        QTime time = QTime::fromString(str);
+        if (ok) *ok = time.isValid();
+        return time;
+    }
+
+    enum TimeProcessingOption { ProcessStrict = 0x1, ProcessNonStrict = 0x2 };
+    Q_DECLARE_FLAGS(TimeProcessingOptions, TimeProcessingOption)
+    QTime readLocaleTime(const QString &str, bool *ok = 0, TimeFormatOptions options = KLocale::TimeDefault, TimeProcessingOptions processing = ProcessNonStrict) const
+    {
+        Q_UNUSED(options);
+        Q_UNUSED(processing);
+        QTime time = QTime::fromString(str);
+        if (ok) *ok = time.isValid();
+        return time;
+    }
+
+    QString language() const { return QLocale::languageToString(m_locale.language()); }
+    QString country() const { return QLocale::countryToString(m_locale.country()); }
+    QString countryDivisionCode() const { return country(); }
+
+    /**
+    * Returns the language codes selected by user, ordered by decreasing
+    * priority.
+    *
+    * Use languageCodeToName(language) to get human readable, localized
+    * language name.
+    *
+    * @return list of language codes
+    *
+    * @see languageCodeToName
+    */
+    QStringList languageList() const { return QStringList() << QLocale::languageToString(m_locale.language()); }
+
+    /**
+    * @since 4.4
+    *
+    * Returns the ISO Currency Codes used in the locale, ordered by decreasing
+    * priority.
+    *
+    * Use KCurrency::currencyCodeToName(currencyCode) to get human readable,
+    * localized language name.
+    *
+    * @return list of ISO Currency Codes
+    *
+    * @see currencyCodeToName
+    */
+    QStringList currencyCodeList() const { return QStringList() << m_locale.currencySymbol(QLocale::CurrencyIsoCode); }
+
+#if 0
+    /**
+    * Returns the user's preferred encoding.
+    *
+    * @return The name of the preferred encoding
+    *
+    * @see codecForEncoding
+    * @see encodingMib
+    */
+    const QByteArray encoding() const;
+
+    /**
+    * Returns the user's preferred encoding.
+    *
+    * @return The Mib of the preferred encoding
+    *
+    * @see encoding
+    * @see codecForEncoding
+    */
+    int encodingMib() const;
+
+    /**
+    * Returns the user's preferred encoding. Should never be NULL.
+    *
+    * @return The codec for the preferred encoding
+    *
+    * @see encoding
+    * @see encodingMib
+    */
+    QTextCodec * codecForEncoding() const;
+
+    /**
+    * Returns the file encoding.
+    *
+    * @return The Mib of the file encoding
+    *
+    * @see QFile::encodeName
+    * @see QFile::decodeName
+    */
+    int fileEncodingMib() const;
+#endif
+
+    QString dateFormat() const { return m_locale.dateFormat(QLocale::LongFormat); }
+    QString dateFormatShort() const { return m_locale.dateFormat(QLocale::ShortFormat); }
+    QString timeFormat() const { return m_locale.timeFormat(); }
+
+    void setDateFormat(const QString & format) {Q_UNUSED(format);}
+    void setDateFormatShort(const QString & format) {Q_UNUSED(format);}
+    void setDateMonthNamePossessive(bool possessive) {Q_UNUSED(possessive);}
+    void setTimeFormat(const QString & format) {Q_UNUSED(format);}
+    void setDateTimeDigitSet(DigitSet digitSet) {Q_UNUSED(digitSet);}
+    void setWeekStartDay(int day) {Q_UNUSED(day);}
+    void setWorkingWeekStartDay(int day) {Q_UNUSED(day);}
+    void setWorkingWeekEndDay(int day) {Q_UNUSED(day);}
+    void setWeekDayOfPray(int day) {Q_UNUSED(day);}
+    void setDecimalSymbol(const QString & symbol) {Q_UNUSED(symbol);}
+    void setThousandsSeparator(const QString & separator) {Q_UNUSED(separator);}
+    void setPositiveSign(const QString & sign) {Q_UNUSED(sign);}
+    void setNegativeSign(const QString & sign) {Q_UNUSED(sign);}
+    void setDigitSet(DigitSet digitSet) {Q_UNUSED(digitSet);}
+    void setPositiveMonetarySignPosition(SignPosition signpos) {Q_UNUSED(signpos);}
+    void setNegativeMonetarySignPosition(SignPosition signpos) {Q_UNUSED(signpos);}
+    void setPositivePrefixCurrencySymbol(bool prefix) {Q_UNUSED(prefix);}
+    void setNegativePrefixCurrencySymbol(bool prefix) {Q_UNUSED(prefix);}
+    //KDE_DEPRECATED void setFracDigits(int digits) {}
+    void setDecimalPlaces(int digits) {Q_UNUSED(digits);}
+    void setMonetaryDecimalPlaces(int digits) {Q_UNUSED(digits);}
+    void setMonetaryThousandsSeparator(const QString & separator) {Q_UNUSED(separator);}
+    void setMonetaryDecimalSymbol(const QString & symbol) {Q_UNUSED(symbol);}
+    void setCurrencyCode(const QString &newCurrencyCode) {Q_UNUSED(newCurrencyCode);}
+    void setCurrencySymbol(const QString & symbol) {Q_UNUSED(symbol);}
+    void setMonetaryDigitSet(DigitSet digitSet) {Q_UNUSED(digitSet);}
+    //int pageSize() const;
+    //void setPageSize(int paperFormat);
+
+    enum MeasureSystem { Metric, Imperial };
+    MeasureSystem measureSystem() const { return Metric; }
+    void setMeasureSystem(MeasureSystem value) {Q_UNUSED(value);}
+
+    void insertCatalog(const QString& catalog) {Q_UNUSED(catalog);}
+    void removeCatalog(const QString &catalog) {Q_UNUSED(catalog);}
+    void setActiveCatalog(const QString &catalog) {Q_UNUSED(catalog);}
+
+    QString translateQt(const char *context, const char *sourceText, const char *comment) const { Q_UNUSED(comment); return QCoreApplication::translate(context, sourceText); }
+
+#if 0
+    /**
+    * Provides list of all known language codes.
+    *
+    * Use languageCodeToName(language) to get human readable, localized
+    * language names.
+    *
+    * @return list of all language codes
+    *
+    * @see languageCodeToName
+    * @see installedLanguages
+    */
+    QStringList allLanguagesList() const;
+
+    /**
+    * @since 4.6
+    *
+    * Provides list of all installed KDE Language Translations.
+    *
+    * Use languageCodeToName(language) to get human readable, localized
+    * language names.
+    *
+    * @return list of all installed language codes
+    *
+    * @see languageCodeToName
+    */
+    QStringList installedLanguages() const;
+
+    /**
+    * Convert a known language code to a human readable, localized form.
+    * If an unknown language code is supplied, empty string is returned;
+    * this will never happen if the code has been obtained by one of the
+    * KLocale methods.
+    *
+    * @param language the language code
+    *
+    * @return the human readable and localized form if the code is known,
+    *         empty otherwise
+    *
+    * @see language
+    * @see languageList
+    * @see allLanguagesList
+    * @see installedLanguages
+    */
+    QString languageCodeToName(const QString &language) const;
+
+    /**
+    * Provides list of all known country codes.
+    *
+    * Use countryCodeToName(country) to get human readable, localized
+    * country names.
+    *
+    * @return a list of all country codes
+    *
+    * @see countryCodeToName
+    */
+    QStringList allCountriesList() const;
+
+    /**
+    * Convert a known country code to a human readable, localized form.
+    *
+    * If an unknown country code is supplied, empty string is returned;
+    * this will never happen if the code has been obtained by one of the
+    * KLocale methods.
+    *
+    * @param country the country code
+    *
+    * @return the human readable and localized form of the country name
+    *
+    * @see country
+    * @see allCountriesList
+    */
+    QString countryCodeToName(const QString &country) const;
+
+#endif
+
+    /**
+    * Parses locale string into distinct parts.
+    * The format of locale is language_COUNTRY@modifier.CHARSET
+    *
+    * @param locale the locale string to split
+    * @param language set to the language part of the locale
+    * @param country set to the country part of the locale
+    * @param modifier set to the modifer part of the locale
+    * @param charset set to the charset part of the locale
+    */
+    static void splitLocale(const QString &locale, QString &language, QString &country,
+                            QString &modifier, QString &charset);
+
+
+
+    static void setMainCatalog(const char *catalog) {Q_UNUSED(catalog);}
+
+#if 0
+    /**
+    * @deprecated
+    *
+    * Finds localized resource in resourceDir( rtype ) + \<lang> + fname.
+    *
+    * Since KDE 4.1, this service is provided in a slightly different form,
+    * automatically by e.g. KStandardDirs::locate() and other KDE core classes
+    * dealing with paths. For manual use, it is replaced by localizedFilePath().
+    *
+    * @param fname relative path to find
+    * @param rtype resource type to use
+    *
+    * @return path to localized resource
+    *
+    * @see localizedFilePath
+    */
+    static QString langLookup(const QString &fname, const char *rtype = "html");
+
+    /**
+    * Returns the name of the internal language.
+    *
+    * @return Name of the default language
+    */
+    static QString defaultLanguage();
+
+    /**
+    * Returns the code of the default country, i.e. "C"
+    *
+    * This function will not provide a sensible value to use in your app,
+    * please use country() instead.
+    *
+    * @see country
+    *
+    * @return Name of the default country
+    */
+    static QString defaultCountry();
+
+    /**
+    * @since 4.4
+    *
+    * Returns the ISO Code of the default currency.
+    *
+    * @return ISO Currency Code of the default currency
+    */
+    static QString defaultCurrencyCode();
+
+    /**
+    * Reports whether evaluation of translation scripts is enabled.
+    *
+    * @return true if script evaluation is enabled, false otherwise.
+    */
+    bool useTranscript() const;
+
+    /**
+    * Checks whether or not the active catalog is found for the given language.
+    *
+    * @param language language to check
+    */
+    bool isApplicationTranslatedInto(const QString & language);
+
+    /**
+    * Copies the catalogs of this object to an other KLocale object.
+    *
+    * @param locale the destination KLocale object
+    */
+    void copyCatalogsTo(KLocale *locale);
+
+    /**
+    * Changes the current country. The current country will be left
+    * unchanged if failed. It will force a reload of the country specific
+    * configuration.
+    *
+    * An empty country value will set the country to the system default.
+    *
+    * If you specify a configuration file, a setLocale() will be performed on
+    * the config using the current locale language, which may cause a sync()
+    * and reparseConfiguration() which will save any changes you have made.
+    *
+    * @param country the ISO 3166 country code
+    * @param config  a configuration file with a Locale group detailing
+    *                locale-related preferences (such as language and
+    *                formatting options).
+    *
+    * @return @c true on success, @c false on failure
+    */
+    bool setCountry(const QString & country, KConfig *config);
+
+    /**
+    * @since 4.6
+    *
+    * Sets the Country Division Code of the Country where the user lives.
+    *
+    * The code must comply with the ISO 3166-2 standard.
+    * See http://en.wikipedia.org/wiki/ISO_3166-2 for details.
+    *
+    * In KDE 4.6 it is the apps responsibility to validate the input,
+    * full validation and other services will be provided in KDE 4.7.
+    *
+    * @param countryDivision the Country Division Code for the user
+    * @return @c true on success, @c false on failure
+    * @see countryDivisionCode
+    */
+    bool setCountryDivisionCode(const QString & countryDivision);
+
+    /**
+    * Changes the current language. The current language will be left
+    * unchanged if failed. It will force a reload of the country specific
+    * configuration as well.
+    *
+    * If you specify a configuration file, a setLocale() will be performed on
+    * the config using the current locale language, which may cause a sync()
+    * and reparseConfiguration() which will save any changes you have made.
+    *
+    * @param language the language code
+    * @param config   a configuration file with a Locale group detailing
+    *                 locale-related preferences (such as language and
+    *                 formatting options).
+    *
+    * @return true on success
+    */
+    bool setLanguage(const QString &language, KConfig *config);
+
+    /**
+    * Changes the list of preferred languages for the locale. The first valid
+    * language in the list will be used, or the default language (en_US)
+    * if none of the specified languages were available.
+    *
+    * @param languages the list of language codes
+    *
+    * @return true if one of the specified languages were used
+    */
+    bool setLanguage(const QStringList &languages);
+#endif
+
+    QString localizedFilePath(const QString &filePath) const { return filePath; }
+
+#if 0
+    /**
+    * @since 4.2
+    *
+    * Removes accelerator marker from a UI text label.
+    *
+    * Accelerator marker is not always a plain ampersand (&),
+    * so it is not enough to just remove it by @c QString::remove().
+    * The label may contain escaped markers ("&&") which must be resolved
+    * and skipped, as well as CJK-style markers ("Foo (&F)") where
+    * the whole parenthesis construct should be removed.
+    * Therefore always use this function to remove accelerator marker
+    * from UI labels.
+    *
+    * @param label UI label which may contain an accelerator marker
+    * @return label without the accelerator marker
+    */
+    QString removeAcceleratorMarker(const QString &label) const;
+
+    /**
+    * @since 4.3
+    *
+    * Convert all digits in the string to the given digit set.
+    *
+    * Conversion is normally not performed if the given digit set
+    * is not appropriate in the current locale and language context.
+    * Unconditional conversion may be requested by setting
+    * @p ignoreContext to @c true.
+    *
+    * @param str the string to convert
+    * @param digitSet the digit set identifier
+    * @param ignoreContext unconditional conversion if @c true
+    *
+    * @return string with converted digits
+    *
+    * @see DigitSet
+    */
+    QString convertDigits(const QString &str, DigitSet digitSet,
+                        bool ignoreContext = false) const;
+
+    /**
+    * @since 4.8
+    *
+    * Reparse locale configuration files for the current selected
+    * language.
+    */
+    void reparseConfiguration();
+#endif
+
+private:
+    QLocale m_locale;
+    KCalendarSystem *m_calendar;
+};
+#if 0
+/**
+ * Qt's uic generated translation calls go through numerous indirections
+ * unnecessary in our case. So we use <tt>uic -tr tr2i18n</tt> to redirect them
+ * to ki18n API.
+**/
+inline QString tr2i18n (const char *message, const char *comment = 0) {
+    if (comment && comment[0] && message && message[0]) {
+        return ki18nc(comment, message).toString();
+    }
+    else if (message && message[0]) {
+        return ki18n(message).toString();
+    }
+    else {
+        return QString();
+    }
+}
+#endif
+#endif
diff --git a/sheets/kreplace.h b/sheets/kreplace.h
new file mode 100644
index 00000000000..da820d3fdbd
--- /dev/null
+++ b/sheets/kreplace.h
@@ -0,0 +1,28 @@
+#ifndef FAKE_KREPLACE_H
+#define FAKE_KREPLACE_H
+
+#include <kfind.h>
+
+class KReplace : public KFind
+{
+public:
+    KReplace(const QString &pattern, const QString &replacement, long options, QWidget *parent = 0) : KFind(pattern, options, parent) {}
+    KReplace(const QString &pattern, const QString &replacement, long options, QWidget *parent, QWidget* replaceDialog) : KFind(pattern, options, parent, replaceDialog) {}
+    virtual ~KReplace() {}
+
+    int numReplacements() const { return 0; }
+    virtual void resetCounts() {}
+    Result replace() { return NoMatch; }
+    QDialog* replaceNextDialog( bool create = false) { return 0; }
+    void closeReplaceNextDialog() {}
+    static int replace( QString &text, const QString &pattern, const QString &replacement, int index, long options, int *replacedLength ) { return 0; }
+    static int replace( QString &text, const QRegExp &pattern, const QString &replacement, int index, long options, int *replacedLength ) { return 0; }
+    virtual bool shouldRestart( bool forceAsking = false, bool showNumMatches = true ) const { return false; }
+    virtual void displayFinalDialog() const {}
+#if 0
+Q_SIGNALS:
+    void replace(const QString &text, int replacementIndex, int replacedLength, int matchedLength);
+#endif
+};
+
+#endif
diff --git a/sheets/kreplacedialog.h b/sheets/kreplacedialog.h
new file mode 100644
index 00000000000..37a09c614e8
--- /dev/null
+++ b/sheets/kreplacedialog.h
@@ -0,0 +1,22 @@
+#ifndef FAKE_KREPLACEDIALOG_H
+#define FAKE_KREPLACEDIALOG_H
+
+#include <kfinddialog.h>
+
+class KReplaceDialog : public KFindDialog
+{
+public:
+    enum Options { PromptOnReplace = 256, BackReference = 512 };
+    explicit KReplaceDialog( QWidget *parent = 0, long options = 0, const QStringList &findStrings = QStringList(), const QStringList &replaceStrings = QStringList(), bool hasSelection = true ) : KFindDialog(parent, options, findStrings, hasSelection) {}
+    void setReplacementHistory( const QStringList &history ) { m_replacementHistory = history; }
+    QStringList replacementHistory() const { return m_replacementHistory; }
+    //void setOptions( long options ) {}
+    //long options() const {}
+    QString replacement() const { return m_replacement; }
+    QWidget *replaceExtension() const { return 0; }
+private:
+    QStringList m_replacementHistory;
+    QString m_replacement;
+};
+
+#endif
diff --git a/sheets/ktextedit.h b/sheets/ktextedit.h
new file mode 100644
index 00000000000..11077d4cef4
--- /dev/null
+++ b/sheets/ktextedit.h
@@ -0,0 +1,13 @@
+#ifndef FAKE_KTEXTEDIT_H
+#define FAKE_KTEXTEDIT_H
+
+#include <QTextEdit>
+
+class KTextEdit : public QTextEdit
+{
+public:
+    KTextEdit(QWidget *parent = 0) : QTextEdit(parent) {}
+    KTextEdit(const QString &text, QWidget *parent) : QTextEdit(text, parent) {}
+};
+
+#endif
-- 
2.23.0

